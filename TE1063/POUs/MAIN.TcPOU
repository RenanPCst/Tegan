<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="MAIN" Id="{cebf6aa5-5e58-48d5-8759-1298446923a5}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN

VAR
	// Axis Motion Controls
	PosFB				: FB_GetPosition;
	MoveFB				: FB_MotorControl;
	fbSetZero			: MC_SetPosition;
	fbReadStatus		: MC_ReadStatus;
	rCurrentPosition 	: LREAL;
	bGetPosition		: BOOL := FALSE;
	bMoveStart			: BOOL := FALSE;
	bMoveDone			: BOOL;
	bPosError			: BOOL;
	nPosErrorID			: UDINT;

    // Axis Motion Status and Errors
    bPowerStatus  	: BOOL;              		// Indicates whether the engine is enabled
    bBusy         	: BOOL;              		// Indicates whether the axis is moving
    bDone         	: BOOL;              		// Indicates that the position has been reached
    bError        	: BOOL;              		// Indicates error
    nErrorID      	: UDINT;             		// Error code
	sState		  	: STRING;					// String containing the error status
		
	bZeroDone		:	BOOL;
	bZeroError		:	BOOL;
	nZeroErrorID	:	UDINT;
	bSetZero		:	BOOL := FALSE;
	
	//Moviment testing Motos and Valves
	fbValveController : FB_ValvePositionControl; 	//FB Instance
		EnableServo     : BOOL := FALSE;
		DesiredPos      : INT;   				// Choose valve position(1 a 6)
		MoveNow         : BOOL := FALSE;
		ValveInPosition : BOOL;
	
	//MC_Power responsible to enable the motor
	fbMcPower 		: MC_Power;
	bPowerEnable	: BOOL := FALSE;
	PowerErrorID	: UDINT;
	
	//Balance FB call and Testing
	fbTcpClient						: FB_TCPClient;
		bConnectionDone				: BOOL 			:= FALSE;
		fMeasuredWeight				: REAL;
    	sResponseMessage			: STRING(255);
    	bStartCommunication			: BOOL 			:= FALSE;  
    	tAdjustableDelay			: TIME 			:= T#100MS;  //Configured time between the states.
		
	//Event Logger call and testing
	fbEventHandler		: FB_EventHandler;
		bExecuteEvent	: BOOL := FALSE;
		bEventDone		: BOOL := FALSE;
	
	//Alarm Raise and Confirm Example
	fbAlarm				: FB_AlarmHandler;
		bAlarmEvent		: BOOL := FALSE;
		bConfirm		: BOOL := FALSE;
		bDoSomething	: BOOL;
		
	//Pressure Scaling Value testing
	fbSensorScaling		: FB_SensorScaling;
		bPressureInput	: BOOL := FALSE;
		rPressureSensor	: REAL;
		bPressureExecute: BOOL := FALSE;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Call State Machine and peripheral programs
PRG_StateMachine(); 
PRG_UpdateVariablesMoving();
PRG_SafetyHandle();

//<Event Logger Test>----------------------------------------------------------------------------------------------------------------------------
// Events call
fbEventHandler(
	bExecute 	:= bExecuteEvent,		// Triggers the event
	eEventName 	:= E_Events.INFO,		// Selects the type of event to be triggered.
	sSystem		:= 'Safety',			// System message
	sMessage	:= 'Doors not closed!',	// Alarm Message
	bDone		=> bEventDone			// Event Listed
);

IF bEventDone THEN
	bExecuteEvent 	:= FALSE;
	bEventDone		:= FALSE;	
END_IF

//Alarms Call
fbAlarm(
	evtEntry 	:= TC_Events.ASRS.Error,	// Selects the type of event to be triggered.
	bEvt 		:= bAlarmEvent, 			// Triggers the alarm. If TRUE the alarm is raised and when turn into FALSE the alarm is cleared.
	bConfirm 	:= bConfirm,				// Confirms the Alarm State
	sSystem		:= 'Motor M1',				// System message
	sMessage	:= 'Over Voltage!'			// Alarm Message
);
//Do something while the alarm is raised
IF fbAlarm.eConfirmationState = TcEventConfirmationState.WaitForConfirmation THEN
	bDoSomething 	:= TRUE;
ELSE
	bDoSomething 	:= FALSE;
END_IF

//<\Event Logger Test>---------------------------------------------------------------------------------------------------------------------------

//<Balance Test>---------------------------------------------------------------------------------------------------------------------------------

// FB_TCPClient instance to handle the connection with the Balance and interpretate it's response
fbTcpClient(
    sRemoteHost 	:= GVL_Settings.aBalanceIP,		//Server Ip address
    nRemotePort 	:= GVL_Settings.nBalancePort,	//Server communication Port
    bTrigger 		:= bStartCommunication,				//Triggers the communication
    tStateDelay 	:= tAdjustableDelay,  				//Time delay between the steps [closeAll > Connection > Send > Receive > Parse > Close Connection]
    sParsedResponse	=> sResponseMessage, 				//Personalized Resposse message
    fWeight 		=> fMeasuredWeight, 				//Parsed LReal Weight meassured if eveything goes ok
	bConnectionDone	=> bConnectionDone,					//Communication Finished
    bBusy 			=> ,								//Busy status
    bError 			=> ,								//Error status
    nErrorID 		=> 									//Error ID if in error
);

// Reset Trigger after FB finished
IF bConnectionDone THEN
    bStartCommunication := FALSE;
END_IF

//<\Balance Test>---------------------------------------------------------------------------------------------------------------------------------

//<Pressure Testing>------------------------------------------------------------------------------------------------------------------------------
IF bPressureInput THEN
	fbSensorScaling(iRawValue := GVL_IO.gAnalogInputs.rMainPressureSupplyInput, iSensorID := 1, rPressure => rPressureSensor);
END_IF



//<\Pressure Testing>-----------------------------------------------------------------------------------------------------------------------------

//Motors Moviment Test M1 >> M8 ------------------------------------------------------------------------------------------------------------------
//Get actual position from Motor 1
IF bGetPosition THEN	
	PosFB(
		bEnable			:=	bGetPosition,
		AxisRef			:=	GVL_Motion.M1Motor.Axis,
		bError			=>	bPosError,
		nErrorID		=>	nPosErrorID,
		rPosition		=>	GVL_Motion.M1Motor.rActualPosition
	);
END_IF

//Get actual position from motor M2
IF bGetPosition THEN	
	PosFB(
		bEnable			:=	bGetPosition,
		AxisRef			:=	GVL_Motion.M2Motor.Axis,
		bError			=>	bPosError,
		nErrorID		=>	nPosErrorID,
		rPosition		=>	GVL_Motion.M2Motor.rActualPosition
	);
END_IF

//Get actual position from motor M3
IF bGetPosition THEN	
	PosFB(
		bEnable			:=	bGetPosition,
		AxisRef			:=	GVL_Motion.M3Motor.Axis,
		bError			=>	bPosError,
		nErrorID		=>	nPosErrorID,
		rPosition		=>	GVL_Motion.M3Motor.rActualPosition
	);		
END_IF

//Get actual position from motor M4
IF bGetPosition THEN	
	PosFB(
		bEnable			:=	bGetPosition,
		AxisRef			:=	GVL_Motion.M4Valve1.Axis,
		bError			=>	bPosError,
		nErrorID		=>	nPosErrorID,
		rPosition		=>	GVL_Motion.M4Valve1.rAtualPosition
	);		
END_IF

//Get actual position from motor M5
IF bGetPosition THEN	
	PosFB(
		bEnable			:=	bGetPosition,
		AxisRef			:=	GVL_Motion.M5Valve2.Axis,
		bError			=>	bPosError,
		nErrorID		=>	nPosErrorID,
		rPosition		=>	GVL_Motion.M5Valve2.rAtualPosition
	);		
END_IF

//Get actual position from motor M6
IF bGetPosition THEN	
	PosFB(
		bEnable			:=	bGetPosition,
		AxisRef			:=	GVL_Motion.M6Valve3.Axis,
		bError			=>	bPosError,
		nErrorID		=>	nPosErrorID,
		rPosition		=>	GVL_Motion.M6Valve3.rAtualPosition
	);		
END_IF

//Get actual position from motor M7
IF bGetPosition THEN	
	PosFB(
		bEnable			:=	bGetPosition,
		AxisRef			:=	GVL_Motion.M7Valve4.Axis,
		bError			=>	bPosError,
		nErrorID		=>	nPosErrorID,
		rPosition		=>	GVL_Motion.M7Valve4.rAtualPosition
	);		
END_IF

//Get actual position from motor M8
IF bGetPosition THEN	
	PosFB(
		bEnable		:=	bGetPosition,
		AxisRef		:=	GVL_Motion.M8Valve5.Axis,
		bError		=>	bPosError,
		nErrorID	=>	nPosErrorID,
		rPosition	=>	GVL_Motion.M8Valve5.rAtualPosition
	);		
END_IF

fbMcPower(
    Axis 			:= GVL_Motion.M1Motor.Axis,
    Enable 			:= bPowerEnable, //Enable the Axis if the driver is ready without safety fauls
    Enable_Positive := bPowerEnable, //Enable for positive moviments
    Enable_Negative := bPowerEnable, //Enable for negative moviments
	ErrorID			=> PowerErrorID	 //Error ID if the power enter in error.
);

//Valves servormotor testing [M4, M5, M6, M7, M8]
DesiredPos := 5;

IF NOT ValveInPosition AND EnableServo THEN
fbValveController(
    bEnable 		:= EnableServo,
	ServoAxis		:= GVL_Motion.M4Valve1.Axis,
    iValvePosition 	:= DesiredPos,
	bMoveDone		=> ValveInPosition
);

END_IF

//target positions test for the motors
GVL_Motion.M1Motor.rTargetPosition 	:= 0;
GVL_Motion.M1Motor.rTargetVelocity	:= 15;

GVL_Motion.M3Motor.iTargetPosition	:= 0;
GVL_Motion.M3Motor.iTargetVelocity	:= 5;

GVL_Motion.M2Motor.iTargetPosition	:= 0;
GVL_Motion.M2Motor.iTargetVelocity	:= 5;

//Set position 0
fbSetZero(
    Execute := bSetZero,
    Axis := GVL_Motion.M3Motor.Axis,
    Position := 0.0,  // Define a posição atual como zero
    Done => bZeroDone,
    Error => bZeroError,
    ErrorID => nZeroErrorID
);

//Motors Moving testing [M1, M2, M3]
IF bMoveStart AND GVL_Safety.iMotorsSTOEnabled THEN
    MoveFB(
        bEnable 	:= TRUE,
        AxisRef 	:= GVL_Motion.M2Motor.Axis, 
        nPosition 	:= GVL_Motion.M2Motor.iTargetPosition, 
        nVelocity 	:= GVL_Motion.M2Motor.iTargetVelocity,
        bDone		=> bMoveDone,
        bError		=> bPosError,
        nErrorID	=> nPosErrorID,
        sState		=> sState
    );
END_IF

// Reset bMoveStart when move is completed
IF bMoveDone THEN
    bMoveStart := FALSE;
END_IF



]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="3102" Count="63" />
      <LineId Id="3169" Count="155" />
      <LineId Id="767" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>