<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_ValvePositionControl" Id="{9a366dfb-6783-408c-9907-1d3bb649c87c}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ValvePositionControl
VAR_INPUT
	bEnable      	: BOOL;			// Enables the FB
    iValvePosition	: INT;   		// Desired Position to move the valve (1 a 6)
END_VAR
VAR_OUTPUT
	iActualPosition : INT;  		// Actual valve position
    bMoveDone       : BOOL; 		// 
	bBusy		   	: BOOL;
    bError          : BOOL; 		// Indicates whether the movement has finished
	iErrorID		: UDINT;
END_VAR
VAR_IN_OUT
	ServoAxis    	: AXIS_REF;  	// Axis Reference
END_VAR
VAR
    MC_Power     		: MC_Power;
    MC_MoveAbs   		: MC_MoveAbsolute;
    MC_Reset     		: MC_Reset;
    rTargetPos    		: LREAL; 		// Target position in degrees
    iState        		: INT := 0; 	// State machine initializing in 0
    iModeOfOperation	: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Defines the valve positions within 0-360°
CASE iValvePosition OF
    1: rTargetPos := 0.0;
    2: rTargetPos := 60.0;
    3: rTargetPos := 120.0;
    4: rTargetPos := 180.0;
    5: rTargetPos := 240.0;
    6: rTargetPos := 300.0;
ELSE
    rTargetPos := 0.0; // Default position if input is invalid
END_CASE

// State machine to ensure the correct sequence of operations
CASE iState OF
    0: // Checks if the drive needs to be enabled
        MC_Power(
            Axis := ServoAxis,
            Enable := bEnable,
            Enable_Positive := bEnable,
            Enable_Negative := bEnable
        );

        IF MC_Power.Error THEN
            iState := 1; // If an error occurs, go to reset state
        ELSIF MC_Power.Active THEN
            iState := 2; // If the drive is enabled, proceed to motion state
        END_IF;

    1: // Resets error before continuing
        MC_Reset(
            Axis := ServoAxis,
            Execute := TRUE
        );

        IF NOT MC_Reset.Busy THEN
            iState := 0; // Return to drive enabling state
        END_IF;

    2: // Ensures the drive is in the correct mode before movement
        //ModeOfOperation := 1; // Profile Position Mode (PPM)

        IF MC_Power.Active THEN
            iState := 3; // Proceed to movement state
        END_IF;

    3: // Executes the movement if the drive is enabled
        MC_MoveAbs(
            Axis := ServoAxis,
            Position := rTargetPos,   // Sets the target position within 0 to 360°
            Velocity := 5.0,        // Movement velocity
            Acceleration := 10.0,   // Acceleration
            Deceleration := 10.0,   // Deceleration
            Execute := bEnable
        );

        IF MC_MoveAbs.Done THEN
            iState := 4; // Once the movement is complete, update variables
        END_IF;

    4: // Updates status and returns to the initial state
        bBusy 			:= MC_MoveAbs.Busy;
        bMoveDone 		:= MC_MoveAbs.Done;
        bError 			:= MC_MoveAbs.Error;
        iActualPosition := iValvePosition;

        // Returns to the initial state, waiting for a new command
        IF bMoveDone THEN
            iState := 0;
        END_IF;
END_CASE;]]></ST>
    </Implementation>
    <LineIds Name="FB_ValvePositionControl">
      <LineId Id="204" Count="68" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>