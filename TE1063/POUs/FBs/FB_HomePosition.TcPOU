<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_HomePosition" Id="{a4f8c8e7-dddf-4a94-bcd4-7e3204ae2ea0}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_HomePosition
VAR_INPUT
    eMotor       : E_Motors;   // Motor selecionado
    bStartHoming : BOOL;       // Comando para iniciar o homing
END_VAR

VAR_OUTPUT
    bHomingDone  : BOOL;       // Indica que o homing foi concluído
    bError       : BOOL;       // Indica erro no processo de homing
END_VAR

VAR
    axisPointer  : POINTER TO AXIS_REF;
    bHomeSensor  : POINTER TO BOOL;
    sAxisName    : STRING(256);
    
    fbMove       : FB_MoveVelocity;
    fbHome       : MC_Home;
    fbStop       : MC_Stop;
		bStop	 : BOOL := TRUE;
	fbReset		 : MC_Reset;

    bMoveAxis    : BOOL := FALSE;
    iState       : INT := 0;
    
    tTimer       : TON; // Temporizador para garantir tempo entre estados
    bTimerDone   : BOOL := FALSE;
	bHomeSensorNow: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// ======== MÁQUINA DE ESTADOS COM RESET DO STOPFB =========
CASE iState OF

    // Seleciona o eixo correto baseado no enum
    0:  
        CASE eMotor OF
            E_Motors.M1StageCollection:
                axisPointer := ADR(GVL_Motion.M1Motor.Axis);
                bHomeSensor := ADR(GVL_IO.gDigInputs.bStageCollection_Home);
                sAxisName   := 'M1';
            E_Motors.M2SampleRecVertical:
                axisPointer := ADR(GVL_Motion.M2Motor.Axis);
                bHomeSensor := ADR(GVL_IO.gDigInputs.bSampleRecovery_Vertical_Home);
                sAxisName   := 'M2';
            E_Motors.M3SampleRecHorizontal:
                axisPointer := ADR(GVL_Motion.M3Motor.Axis);
                bHomeSensor := ADR(GVL_IO.gDigInputs.bSampleRecovery_Horizontal_Home);
                sAxisName   := 'M3';
            ELSE
                bError := TRUE;
                iState := 99; // Estado de erro
        END_CASE;

        IF NOT bError THEN
            tTimer(IN := TRUE, PT := T#500MS); // Tempo antes de iniciar movimento
            IF tTimer.Q THEN
                iState := 1;
            END_IF;
        END_IF;

    // Mover eixo até o sensor home
    1:	
		bHomeSensorNow := bHomeSensor^;
        IF bHomeSensorNow THEN  // **Corrigido: Motor só move se o sensor NÃO estiver acionado**
            fbMove(
                Axis       := axisPointer^,
                Velocity   := 10.0, // Velocidade segura para homing
                bExecute   := TRUE,
                iDirection := 1    // Defina a direção correta para cada motor
            );
            tTimer(IN := TRUE, PT := T#1S); // Aguarda antes de verificar o sensor
        ELSE
            iState := 2; // Se já está no sensor, ir para o próximo estado
        END_IF;

    // Espera o eixo chegar no sensor e para o motor
    2:
		bHomeSensorNow := bHomeSensor^;
        IF NOT bHomeSensorNow THEN
			bStop := TRUE;
		END_IF
	
		// **Chama StopFB para parar o eixo**
		fbStop(
			Axis         := axisPointer^,
			Execute      := bStop,   // Para o eixo com desaceleração
			Deceleration := 10.0  
		);
		IF fbStop.done AND bHomeSensorNow THEN
			bStop := FALSE;
		END_IF
		
		IF fbStop.done AND fbStop.Busy THEN
			fbReset(Axis := axisPointer^ , Execute := TRUE);
		END_IF
		
        IF NOT fbStop.Busy AND NOT bHomeSensorNow THEN
		tTimer(IN := TRUE, PT := T#1S); // Tempo antes de resetar StopFB
        iState := 3; 
		END_IF
        

    // **Resetar MC_Stop Antes de Iniciar o Homing**
    3:
        IF tTimer.Q THEN
            fbStop.Execute := FALSE;  // **Resetamos StopFB antes de seguir**
			
            tTimer(IN := TRUE, PT := T#500MS); // Tempo antes de chamar o homing
            iState := 4;
        END_IF;

    // Executar o homing do eixo
    4:
        IF tTimer.Q THEN // Aguarda tempo antes de iniciar o homing
            fbHome(
                Execute         := TRUE,
                Axis            := axisPointer^,
                Position        := 0.0,
                HomingMode      := MC_Direct
            );

            IF fbHome.Done THEN
                bHomingDone := TRUE;
                tTimer(IN := TRUE, PT := T#500MS); // Pequeno tempo antes de finalizar
                IF tTimer.Q THEN
                    iState := 5; 
                END_IF;
            END_IF;

            IF fbHome.Error THEN
                bError := TRUE;
                iState := 99; // Estado de erro
            END_IF;
        END_IF;

    // Homing completo
    5:
        bHomingDone := TRUE; // Indica que o homing foi realizado
        iState := 0; // Reinicia para permitir novo homing no futuro

    // Estado de erro
    99:
        bError := TRUE; // Manter erro ativo para diagnóstico

END_CASE;]]></ST>
    </Implementation>
    <LineIds Name="FB_HomePosition">
      <LineId Id="992" Count="31" />
      <LineId Id="1103" Count="0" />
      <LineId Id="1024" Count="13" />
      <LineId Id="1101" Count="0" />
      <LineId Id="1038" Count="0" />
      <LineId Id="1094" Count="0" />
      <LineId Id="1097" Count="1" />
      <LineId Id="1096" Count="0" />
      <LineId Id="1042" Count="4" />
      <LineId Id="1105" Count="2" />
      <LineId Id="1047" Count="0" />
      <LineId Id="1109" Count="2" />
      <LineId Id="1108" Count="0" />
      <LineId Id="1048" Count="0" />
      <LineId Id="1099" Count="0" />
      <LineId Id="1049" Count="0" />
      <LineId Id="1100" Count="0" />
      <LineId Id="1050" Count="43" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>