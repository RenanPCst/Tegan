<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_CalibrationManager" Id="{f5b6651e-f67d-465b-b243-425be4d72cd5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CalibrationManager
VAR_INPUT
    bExecute         : BOOL; // Trigger to start calibration
    bAbort           : BOOL; // Trigger to abort trigger
    eSolvent         : E_SolventType; // Selected solvent type
	rSolventDensity  : LREAL; //Solvent Density
    aPumpSettings    : ARRAY[1..10] OF ST_CalibrationPump; // Pump input settings
    tDelayStart      : TIME; // Optional delay before calibration starts
    bPrintReport     : BOOL; // Option to print report at end
END_VAR

VAR_OUTPUT
    aPumpResults     : ARRAY[1..10] OF ST_CalibrationPump; // Pump result structure
    bDone            : BOOL; // Signals end of calibration
    bBusy            : BOOL; // Calibration in progress
    sStatus          : STRING; // Textual status
	iDataCount		 : INT; // Number of positions used into GVL_Calibration.aCalibCheckResult array
END_VAR

VAR
    eStep             	  : E_CalibStep := E_CalibStep.IDLE; // Main step enum
    iPumpIndex        	  : INT := 1; // Tracks current pump
    iReplicate        	  : INT := 0; // Tracks current replicate
	bStartCalibration 	  : BOOL := FALSE;
	bCalibrationRequested : BOOL := FALSE;

    tonCalDelay      : TON; // General delay timer
    tonStepTimeout   : TON; // Timeout per step
	tonMotorsDelay	 : ton; // Delay time after positioning the motors
	tonWeigthStabilization : TON; //Time after the pump finish to wait for stable weigth
	
	bExecutePulse   : R_TRIG; // Edge detection for bExecute

    aPumpMask        : ARRAY[1..10] OF BOOL; // Mask for pump selection
    aVolumeSetpoint  : ARRAY[1..10] OF REAL; // Target volume for each pump
    aDirection       : ARRAY[1..10] OF E_PumpDirection; // Direction per pump
    aVelocity        : ARRAY[1..10] OF REAL; // Velocity per pump

    fbPumps          : FB_AllPumpsController; // Instance of pump controller
    rWeightBefore    : LREAL; // Weight before pump operation
    rWeightAfter     : LREAL; // Weight after pump operation
    rWeightDelta     : LREAL; // Weight difference
	rVolume			 : LREAL; // Volume calculated 
    bRequestWeight   : BOOL := FALSE; // Trigger for requesting scale
	bWeightReady	 : BOOL := FALSE; // Trigger when weigth is ready
    rScaleWeight     : LREAL; // Latest scale result
	rDistanceByVol	 : LREAL; // MoveRelative distance
	rPercentDifference : LREAL; //Percentual Difference between net volume and tagert volume
	
    rAcceptanceCrit  : REAL := 0.5; // Acceptance percentage (from HMI)
    iAllowableFail   : INT := 2; 	// Max failures from pump settings
    iMaxReplicates   : INT := 2; 	// Replicate count (from HMI)
	iResultIndex	 : INT;		 	// Array index on calibration results
	
	bMovePump		 : BOOL := FALSE;
    bMoveMotorM2     : BOOL := FALSE; // Motion trigger M2
    bMoveMotorM3     : BOOL := FALSE; // Motion trigger M3
    bMoveValve       : ARRAY[1..5] OF BOOL; // Valve position tracking

    i                : USINT;// Loop index helper
    bBoxPresent      : BOOL; // True if calibration box detected
    bBoxWeightOK     : BOOL; // True if calibration box has valid weight

    tStepTimeout     : TIME := T#60S; // Default timeout per step;
	tWeightStable	 : TIME := T#20S; // Default waiting time befe request weight
	
	// Scale-attention handling (9999 pause)
    bScaleAttention  : BOOL := FALSE; // TRUE while waiting operator
	bCalBoxAttention : BOOL := FALSE; // TRUE while waiting operator
    eStepResume      : E_CalibStep := E_CalibStep.IDLE; // Step to return to after fix
	
	// Timestamp generation (local system time)
    fbLocalSystemTime : FB_LocalSystemTime;
    stLocal           : TIMESTRUCT;
    sStamp            : STRING(32);
    sHH               : STRING(2);
    sMM               : STRING(2);
    sSS               : STRING(2);
    sMMo              : STRING(3);
    sDD               : STRING(2);
	bDTReady		  : BOOL := FALSE;
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// bExecute Rising edge
bExecutePulse(CLK := bExecute);

// FB Trigger
IF bExecutePulse.Q AND eStep = E_CalibStep.IDLE THEN
    bStartCalibration := TRUE;
END_IF

// Abort logic
IF bAbort THEN
    eStep := E_CalibStep.ERROR;
END_IF

// State machine
CASE eStep OF

    E_CalibStep.IDLE:
    	bBusy := FALSE;
		bDone := FALSE;
		sStatus := 'Idle';
		IF bStartCalibration THEN
			bBusy := TRUE;
			iPumpIndex := 1;
			iReplicate := 0;
			iResultIndex := 1; // first log row
			bStartCalibration := FALSE;
			eStep := E_CalibStep.DELAY;
		END_IF

    E_CalibStep.DELAY:

        tonCalDelay(IN := TRUE, PT := tDelayStart);
        sStatus := 'Waiting delay...';
        IF tonCalDelay.Q THEN
            tonCalDelay(IN := FALSE);
            tonStepTimeout(IN := FALSE);
            eStep := E_CalibStep.CHECKING_WEIGH;
			bRequestWeight := TRUE;
			bBoxWeightOK := FALSE;
			bWeightReady := FALSE;
        END_IF

	
    E_CalibStep.CHECKING_WEIGH:

		tonStepTimeout(IN := TRUE, PT := tStepTimeout);
		sStatus := 'Checking the Calibration Box Weigth';
        bBoxPresent := GVL_IO.gDigInputs.bCalibrationBoxPresent;
		
		// Request non-blocking reading
		IF bRequestWeight THEN
			rScaleWeight := GVL_Calibration.fbScaleDevice.RequestWeight();
			IF GVL_Calibration.fbScaleDevice.bWeightReady THEN
				// if returns 9999 pause and wait operator
				IF rScaleWeight = 9999.0 THEN
					tonCalDelay(IN := FALSE);
					tonStepTimeout(IN := FALSE);
					tonWeigthStabilization(IN := FALSE);
	
					GVL_HMI.bScaleNeedsAtention := TRUE;
					bScaleAttention := TRUE;
	
					bRequestWeight := FALSE;
					bWeightReady   := FALSE;
	
					eStepResume := E_CalibStep.CHECKING_WEIGH;
					eStep := E_CalibStep.SCALE_ATTENTION;
				ELSE
					bWeightReady   := TRUE;
					bRequestWeight := NOT GVL_Calibration.fbScaleDevice.Reset();
				END_IF
			END_IF
		END_IF

		IF bWeightReady THEN
			
			bBoxWeightOK := (rScaleWeight >= 1100.0) AND (rScaleWeight <= 1300.0);
			
			IF tonStepTimeout.Q THEN
				//GVL_HMI.aAlarmFlags[1] := TRUE; // Timeout during motor positioning
				sStatus := 'Timeout while positioning motors';
				eStep := E_CalibStep.ERROR;
			ELSIF NOT bBoxPresent THEN
				//GVL_HMI.bCalibrationBoxMissing := TRUE;
				sStatus := 'Calibration box not present!';
				bBoxWeightOK := FALSE;
				eStep := E_CalibStep.IDLE;
			ELSIF NOT bBoxWeightOK THEN
				//GVL_HMI.bCalibrationBoxEmpty := TRUE;
				tonCalDelay(IN := FALSE);
				tonStepTimeout(IN := FALSE);
				tonWeigthStabilization(IN := FALSE);
				bBoxWeightOK := FALSE;
	
				// Show HMI popup asking operator to fill box to 1100–1300 g
				GVL_HMI.bCalBoxNeedsAttention := TRUE;
				bCalBoxAttention := TRUE;
	
				// Clear current weight request state
				bRequestWeight := FALSE;
				bWeightReady   := FALSE;
	
				// Resume back to this same step after operator presses Continue
				eStepResume := E_CalibStep.CHECKING_WEIGH;
				eStep       := E_CalibStep.CALBOX_ATTENTION;
			ELSE
				//Proceed
				bWeightReady := FALSE;
				bBoxWeightOK := FALSE;
				eStep := E_CalibStep.POSITION_MOTORS;
				rAcceptanceCrit := GVL_Settings.stCalibParameters.rAcceptanceCriteria;
			END_IF
		END_IF
	
	E_CalibStep.POSITION_MOTORS:
	
		sStatus := 'Positioning motors M2 and M3';
				
		// Positioning motors M2 and M3 to calibration position 
		IF NOT bMoveMotorM3 THEN
			bMoveMotorM3 := GVL_Motion.aMotors[3].MoveAbsolute(GVL_Settings.stMachineParam.aM3Position[6], GVL_Settings.stMachineParam.rM3Velocity, GVL_Settings.stMachineParam.rM3Accleration, GVL_Settings.stMachineParam.rM3Deceleration);
		END_IF
		IF NOT bMoveMotorM2 AND bMoveMotorM3 THEN
			bMoveMotorM2 := GVL_Motion.aMotors[2].MoveAbsolute(GVL_Settings.stMachineParam.aM2Position[4], GVL_Settings.stMachineParam.rM2Velocity, GVL_Settings.stMachineParam.rM2Accleration, GVL_Settings.stMachineParam.rM2Deceleration);
		END_IF
	
		IF bMoveMotorM2 AND bMoveMotorM3 THEN
			tonMotorsDelay(in := TRUE, pt := T#200MS);
		END_IF
		
		IF tonMotorsDelay.Q THEN
			tonStepTimeout(IN := FALSE);
			eStep := E_CalibStep.POSITION_VALVES;
		END_IF

    E_CalibStep.POSITION_VALVES:
		//Reset Motors Flags
		bMoveMotorM2 := FALSE;
		bMoveMotorM3 := FALSE;	
		tonMotorsDelay(in := FALSE);
	
		tonStepTimeout(IN := TRUE, PT := tStepTimeout);
        sStatus := 'Positioning valves to Position 6';
		// Positioning the valves to the needles, position 6 
        FOR i := 1 TO 5 DO
            IF NOT bMoveValve[i] THEN
                bMoveValve[i] := GVL_Motion.aValvesObj[i].MoveValve(iPosition := 6, rVelocity := GVL_Motion.aValves[i].rTargetVel, rAcc := GVL_Motion.aValves[i].rAcceleration, rDec := GVL_Motion.aValves[i].rDeceleration);
            END_IF
        END_FOR
       IF bMoveValve[1] AND bMoveValve[2] AND bMoveValve[3] AND bMoveValve[4] AND bMoveValve[5] THEN
			FOR i := 1 TO 5 DO bMoveValve[i] := FALSE; END_FOR
			tonStepTimeout(IN := FALSE);
			eStep := E_CalibStep.FILLJAR_FORWARD; 
		ELSIF tonStepTimeout.Q THEN
			sStatus := 'Timeout while positioning valves';
			eStep := E_CalibStep.ERROR;
		END_IF

	
	E_CalibStep.FILLJAR_FORWARD:

		sStatus := CONCAT('Filling up the jar number: ', TO_STRING(iPumpIndex));
		
		IF aPumpSettings[iPumpIndex].bSelected THEN
			rDistanceByVol := F_VolumeToSteps_Path(rVolume := (aPumpSettings[iPumpIndex].rTargetVolume + GVL_Settings.stPumpParameters.iFillolventTubesFactor), iPumpIndex := iPumpIndex, ePath := E_PumpPath.FromCalBox);
			// Filling up the jar to start the calibration
			IF NOT bMovePump THEN
				bMovePump := GVL_Motion.aPumpsRotary[iPumpIndex].MoveRelative(	Distance := rDistanceByVol, 
																				Velocity := GVL_Settings.stPumpParameters.iRunVelocity * 6, 	//RPM to Degree/sec
																				Acc := GVL_Settings.stPumpParameters.iMeterVelocity * 6,   		//RPM to Degree/sec
																				Dec := GVL_Settings.stPumpParameters.iMeterVelocity * 6			//RPM to Degree/sec
																			 );
			END_IF
	
			IF bMovePump THEN
				tonWeigthStabilization(IN := TRUE, PT := tWeightStable);
				sStatus := 'Waiting for weight stabilization...';
				IF tonWeigthStabilization.Q THEN
					bMovePump := FALSE;
					tonWeigthStabilization(IN := FALSE);
					bRequestWeight := TRUE;
					bWeightReady := FALSE;
					eStep := E_CalibStep.WEIGH_BEFORE;
				END_IF
			END_IF
		ELSE
			// If the pumps was not selected go to next one
			eStep := E_CalibStep.NEXT_PUMP;
		END_IF

	
    E_CalibStep.WEIGH_BEFORE:

        sStatus := 'Taring scale...';
        IF bRequestWeight AND NOT bWeightReady THEN
            rScaleWeight := GVL_Calibration.fbScaleDevice.RequestWeight();
            IF GVL_Calibration.fbScaleDevice.bWeightReady THEN
                IF rScaleWeight = 9999.0 THEN
					tonCalDelay(IN := FALSE);
					tonStepTimeout(IN := FALSE);
					tonWeigthStabilization(IN := FALSE);
	
					GVL_HMI.bScaleNeedsAtention := TRUE;
					bScaleAttention := TRUE;
	
					bRequestWeight := FALSE;
					bWeightReady   := FALSE;
	
					eStepResume := E_CalibStep.WEIGH_BEFORE;
					eStep := E_CalibStep.SCALE_ATTENTION;
				ELSE
					rWeightBefore := rScaleWeight;
					
					GVL_HMI.aCalPumpResults[iPumpIndex].rTareWeight := rWeightBefore;
					GVL_Calibration.aCalibCheckResult[iResultIndex].rTareWeight := rWeightBefore;
					GVL_calibration.stPumpCalibrationData[iResultIndex].rTareWeigth := rWeightBefore;
					GVL_Calibration.aCalibCheckResult[iResultIndex].nPumpIndex := TO_USINT(iPumpIndex);
					GVL_Calibration.stPumpCalibrationData[iResultIndex].iPumpNumber := TO_USINT(iPumpIndex);
	
					bWeightReady   := TRUE;
					bRequestWeight := NOT GVL_Calibration.fbScaleDevice.Reset();
				END_IF
            END_IF
		END_IF
		IF bWeightReady THEN
			IF (rWeightBefore >= 0 AND rWeightBefore <= 1300) THEN
				GVL_HMI.aCalPumpResults[iPumpIndex].rTareWeight := rWeightBefore;
				GVL_Calibration.aCalibCheckResult[iResultIndex].rTareWeight := rWeightBefore;
				GVL_calibration.stPumpCalibrationData[iResultIndex].rTareWeigth := rWeightBefore;
				GVL_Calibration.aCalibCheckResult[iResultIndex].nPumpIndex := TO_USINT(iPumpIndex);
				GVL_Calibration.stPumpCalibrationData[iResultIndex].iPumpNumber := TO_USINT(iPumpIndex);
				rDistanceByVol := 0.0;
				bWeightReady := FALSE;
				eStep := E_CalibStep.WITHDRAW_BACKWARDS;
			ELSE
				eStep := E_CalibStep.ERROR;
			END_IF
		END_IF        

	
    E_CalibStep.WITHDRAW_BACKWARDS:

		sStatus := CONCAT(CONCAT('Check ',CONCAT(TO_STRING(iReplicate + 1),CONCAT(' | Pumping to calibration box: ', TO_STRING(aVolumeSetpoint[iPumpIndex])))),' ml');

		aVolumeSetpoint[iPumpIndex] := aPumpSettings[iPumpIndex].rTargetVolume;
		GVL_Calibration.aCalibCheckResult[iResultIndex].rTargetVolume := aPumpSettings[iPumpIndex].rTargetVolume;
		GVL_calibration.stPumpCalibrationData[iResultIndex].rTargetVolume := aPumpSettings[iPumpIndex].rTargetVolume;
		rDistanceByVol := F_VolumeToSteps_Path(rVolume := aVolumeSetpoint[iPumpIndex], iPumpIndex := iPumpIndex, ePath := E_PumpPath.FillCalBox );
		GVL_Calibration.aCalibCheckResult[iResultIndex].nRevsDone := TO_UINT(rDistanceByVol/360);
		GVL_calibration.stPumpCalibrationData[iResultIndex].iPumpRevs := TO_UINT(rDistanceByVol/360);
		
		IF NOT bMovePump THEN
			bMovePump := GVL_Motion.aPumpsRotary[iPumpIndex].MoveRelative( 	Distance := - rDistanceByVol, 
																			Velocity := GVL_Settings.stPumpParameters.iMeterVelocity * 6, 	//RPM to Degree/sec
																			Acc := GVL_Settings.stPumpParameters.iMeterVelocity * 6, 		//RPM to Degree/sec
																			Dec := GVL_Settings.stPumpParameters.iMeterVelocity * 6			//RPM to Degree/sec
																		 	);
		END_IF
		
		IF bMovePump THEN
			tonWeigthStabilization(in := TRUE, pt := tWeightStable);
			sStatus :='Waiting for weight stabilization...';
			IF tonWeigthStabilization.Q THEN
				bRequestWeight := TRUE;
				bMovePump := FALSE;
				tonWeigthStabilization(IN := FALSE);
				fbLocalSystemTime(bEnable := FALSE);
				bDTReady := FALSE;
				eStep := E_CalibStep.WEIGH_AFTER;
			END_IF
		END_IF


	
    E_CalibStep.WEIGH_AFTER:

		sStatus := 'Requesting Gross Weight... ';
	
        IF bRequestWeight AND NOT bWeightReady THEN
            rScaleWeight := GVL_Calibration.fbScaleDevice.RequestWeight();
            IF GVL_Calibration.fbScaleDevice.bWeightReady THEN
                IF rScaleWeight = 9999.0 THEN
					tonCalDelay(IN := FALSE);
					tonStepTimeout(IN := FALSE);
					tonWeigthStabilization(IN := FALSE);
	
					GVL_HMI.bScaleNeedsAtention := TRUE;
					bScaleAttention := TRUE;
	
					bRequestWeight := FALSE;
					bWeightReady   := FALSE;
	
					eStepResume := E_CalibStep.WEIGH_AFTER;
					eStep := E_CalibStep.SCALE_ATTENTION;
				ELSE
					rWeightAfter := rScaleWeight;
					GVL_HMI.aCalPumpResults[iPumpIndex].rGrossWeight := rWeightAfter;
	
					bWeightReady := TRUE;
					// NET (weight delta)
					rWeightDelta := rWeightAfter - rWeightBefore;
					GVL_HMI.aCalPumpResults[iPumpIndex].rActualVolume := rWeightDelta;
	
					// Mirror to logs
					GVL_Calibration.aCalibCheckResult[iResultIndex].rGrossWeight := rWeightAfter;
					GVL_calibration.stPumpCalibrationData[iResultIndex].rGrossWeigth := rWeightAfter;
					GVL_Calibration.aCalibCheckResult[iResultIndex].rNetWeight := rWeightDelta;
					GVL_calibration.stPumpCalibrationData[iResultIndex].rNetWeigth := rWeightDelta;
	
					// Density-based volume
					GVL_calibration.stPumpCalibrationData[iResultIndex].rNetVolume := rWeightDelta / rSolventDensity;
					rVolume := GVL_calibration.stPumpCalibrationData[iResultIndex].rNetVolume;
	
					bRequestWeight := NOT GVL_Calibration.fbScaleDevice.Reset();
				END_IF
			END_IF	
		END_IF	
		
		 // Produce a timestamp: DD-MMM-YYYY HH:MM:SS
        fbLocalSystemTime(bEnable := TRUE, dwCycle := 5);
		
        IF fbLocalSystemTime.bValid THEN
            stLocal := fbLocalSystemTime.systemTime;

            sMMo := F_MonthString(stLocal.wMonth);
            sDD  := F_TwoDigits(stLocal.wDay);
            sHH  := F_TwoDigits(stLocal.wHour);
            sMM  := F_TwoDigits(stLocal.wMinute);
            sSS  := F_TwoDigits(stLocal.wSecond);

			sStamp := CONCAT(sDD, '-');			//DD-
			sStamp := CONCAT(sStamp, sMMo);		//DD-MMM
			sStamp := CONCAT(sStamp, '-');		//DD-MMM-
			sStamp := CONCAT(sStamp, INT_TO_STRING(stLocal.wYear)); //DD-MMM-YYYY
			sStamp := CONCAT(sStamp, ' '); 		//DD-MMM-YYYY 
			sStamp := CONCAT(sStamp, sHH);		//DD-MMM-YYYY HH
			sStamp := CONCAT(sStamp, ':');		//DD-MMM-YYYY HH:
			sStamp := CONCAT(sStamp, sMM);		//DD-MMM-YYYY HH:MM
			sStamp := CONCAT(sStamp, ':');		//DD-MMM-YYYY HH:MM:
			sStamp := CONCAT(sStamp, sSS); 		//DD-MMM-YYYY HH:MM:SS

			bDTReady := TRUE;			
        ELSE
            sStamp := '00000000_000000'; // Fallback if system time is not valid
        END_IF
		
		IF bWeightReady AND bDTReady THEN
			
			rPercentDifference := ((rVolume - aPumpSettings[iPumpIndex].rTargetVolume)  / aPumpSettings[iPumpIndex].rTargetVolume) * 100;
			GVL_Calibration.stPumpCalibrationData[iResultIndex].rDifferenceUl := rVolume - aPumpSettings[iPumpIndex].rTargetVolume;
			GVL_Calibration.stPumpCalibrationData[iResultIndex].dDateTime := sStamp;
			GVL_Calibration.stPumpCalibrationData[iResultIndex].rDifferencePercent := rPercentDifference;
			GVL_Calibration.stPumpCalibrationData[iResultIndex].rCriteria := rAcceptanceCrit;
			
			//pupulate gross weight and net weight
			IF rPercentDifference <= rAcceptanceCrit THEN
				aPumpResults[iPumpIndex].eStatus := E_CalibrationStatus.PASSED;
				GVL_HMI.aCalPumpResults[iPumpIndex].eStatus := E_CalibrationStatus.PASSED;
 				GVL_Calibration.aCalibCheckResult[iResultIndex].eStatus := E_CalibrationStatus.PASSED;
			ELSE
				GVL_HMI.aCalPumpResults[iPumpIndex].eStatus := E_CalibrationStatus.ADJUSTMENT_NEEDED;
 				GVL_Calibration.aCalibCheckResult[iResultIndex].eStatus := E_CalibrationStatus.ADJUSTMENT_NEEDED;
				(*
				aPumpResults[iPumpIndex].iFailures := aPumpResults[iPumpIndex].iFailures + 1;
				aPumpResults[iPumpIndex].eStatus := E_CalibrationStatus.FAILED;
				GVL_HMI.aCalPumpResults[iPumpIndex].iFailures := aPumpResults[iPumpIndex].iFailures; 
				GVL_HMI.aCalPumpResults[iPumpIndex].eStatus := aPumpResults[iPumpIndex].eStatus; 
				GVL_Motion.aPumps[iPumpIndex].Rotary.rPumpFactorFromCalBox :=
					GVL_Motion.aPumps[iPumpIndex].Rotary.rPumpFactorFromCalBox *
					(rVolumeDelta / aPumpSettings[iPumpIndex].rTargetVolume);
				iReplicate := 0;
				*)
				//eStep := E_CalibStep.PUMPFACTOR_ADJUST;
			END_IF
			
			iReplicate := iReplicate + 1;
			
			GVL_Calibration.stPumpCalibrationData[iResultIndex].sStep := CONCAT('Check ', TO_STRING(iReplicate));
			
			iResultIndex := iResultIndex + 1;
			
			IF iReplicate >= GVL_Settings.stCalibParameters.iReplicatesSetpoint THEN
				eStep := E_CalibStep.EMPTYJAR_BACKWARDS;
			ELSE
				eStep := E_CalibStep.RETURN_FORWARD;
			END_IF
			bWeightReady := FALSE;
		END_IF
	
    E_CalibStep.RETURN_FORWARD:

		sStatus := CONCAT('Returning solvent back to the Jar number : ',TO_STRING(iPumpIndex));
		rDistanceByVol := F_VolumeToSteps_Path(rVolume := (aPumpSettings[iPumpIndex].rTargetVolume + 5), iPumpIndex := iPumpIndex, ePath := E_PumpPath.FromCalBox);
			
        IF NOT bMovePump THEN
			bMovePump := GVL_Motion.aPumpsRotary[iPumpIndex].MoveRelative( 	Distance := rDistanceByVol, 
																			Velocity := GVL_Settings.stPumpParameters.iMeterVelocity * 6, 	//RPM to Degree/sec
																			Acc := GVL_Settings.stPumpParameters.iMeterVelocity * 6, 		//RPM to Degree/sec
																			Dec := GVL_Settings.stPumpParameters.iMeterVelocity * 6			//RPM to Degree/sec
																		  	);
		END_IF
		
		IF bMovePump THEN
			tonWeigthStabilization(IN := TRUE, PT := tWeightStable);
			sStatus := 'Waiting for weight stabilization...';
			IF tonWeigthStabilization.Q THEN
				bMovePump := FALSE;
				tonWeigthStabilization(IN := FALSE);
				bRequestWeight := TRUE;
				bWeightReady := FALSE;
				eStep := E_CalibStep.WEIGH_BEFORE; // Starts next replication
			END_IF
		END_IF

  
	E_CalibStep.EMPTYJAR_BACKWARDS:

		sStatus := CONCAT('Empty the jar number: ',TO_STRING(iPumpIndex));
		aVolumeSetpoint[iPumpIndex] := aPumpSettings[iPumpIndex].rTargetVolume;
		rDistanceByVol := F_VolumeToSteps_Path(rVolume := (aVolumeSetpoint[iPumpIndex] + GVL_Settings.stPumpParameters.iEmptyFactor), iPumpIndex := iPumpIndex, ePath := E_PumpPath.FromCalBox );
		
        IF NOT bMovePump THEN
			bMovePump := GVL_Motion.aPumpsRotary[iPumpIndex].MoveRelative( 	Distance := - rDistanceByVol, 
																			Velocity := GVL_Settings.stPumpParameters.iRunVelocity * 6, 	//RPM to Degree/sec
																			Acc := GVL_Settings.stPumpParameters.iRunVelocity * 6, 		//RPM to Degree/sec
																			Dec := GVL_Settings.stPumpParameters.iRunVelocity * 6			//RPM to Degree/sec
																		  	);
		END_IF
		
		IF bMovePump THEN
			bMovePump := FALSE;
			eStep := E_CalibStep.NEXT_PUMP;
		END_IF
	
    E_CalibStep.NEXT_PUMP:
        iPumpIndex := iPumpIndex + 1;
        iReplicate := 0;
        IF iPumpIndex <= 10 THEN
            eStep := E_CalibStep.FILLJAR_FORWARD;
        ELSE
            eStep := E_CalibStep.HOMING_MOTORS;
        END_IF

	
    E_CalibStep.HOMING_MOTORS:
        sStatus := 'Returning M2 and M3 to home';
				
		IF NOT bMoveMotorM2 THEN
			bMoveMotorM2 := GVL_Motion.aMotors[2].MoveAbsolute(	GVL_Settings.stMachineParam.aM2Position[1], 
																GVL_Settings.stMachineParam.rM2Velocity, 
																GVL_Settings.stMachineParam.rM2Accleration, 
																GVL_Settings.stMachineParam.rM2Deceleration
																);
		END_IF
		IF NOT bMoveMotorM3 AND bMoveMotorM2 THEN
			bMoveMotorM3 := GVL_Motion.aMotors[3].MoveAbsolute(	GVL_Settings.stMachineParam.aM3Position[1], 
																GVL_Settings.stMachineParam.rM3Velocity, 
																GVL_Settings.stMachineParam.rM3Accleration, 
																GVL_Settings.stMachineParam.rM3Deceleration
																);
		END_IF
				
		IF bMoveMotorM2 AND bMoveMotorM3 THEN
			tonMotorsDelay(in := TRUE, pt := T#200MS);
		END_IF
		
		IF tonMotorsDelay.Q THEN
			tonStepTimeout(IN := FALSE);
			eStep := E_CalibStep.REPORT_INFO_UPDATE;
		END_IF
   
	E_CalibStep.REPORT_INFO_UPDATE: //TODO: Update the variables without hardcode
		//Reset Motors Flags
		bMoveMotorM2 := FALSE;
		bMoveMotorM3 := FALSE;	
		tonMotorsDelay(in := FALSE);
		
		//Report Info
		GVL_Calibration.stPumpCalReportInfo.sReportName := GVL_Constant.sPumpCalibrationReportName;
		GVL_Calibration.stPumpCalReportInfo.sReoportSubName := GVL_Constant.sPumpCalibrationReportSubName;
		GVL_Calibration.stPumpCalReportInfo.sDatabaseName := GVL_Constant.sDatabaseName;
		GVL_Calibration.stPumpCalReportInfo.sReportDate := sStamp;
		GVL_Calibration.stPumpCalReportInfo.sPrintedBy := 'Administrator';
		GVL_Calibration.stPumpCalReportInfo.sSystemID := GVL_Constant.sSystemID;
		GVL_Calibration.stPumpCalReportInfo.iPage := 0;
		
		//Calibration Info
		GVL_Retain.iCalibrationNumber := GVL_Retain.iCalibrationNumber + 1;
		GVL_Calibration.stPumpCalibrationInfo.iCalibrationNumber := TO_INT(GVL_Retain.iCalibrationNumber);
		GVL_Calibration.stPumpCalibrationInfo.iAllowableFailures := 2;
		GVL_Calibration.stPumpCalibrationInfo.iCalIntervalDays := 0;
		GVL_Calibration.stPumpCalibrationInfo.iReplicates := GVL_Calibration.iReplicatesSetpoint;
		GVL_Calibration.stPumpCalibrationInfo.iSolventID := '1';
		GVL_Calibration.stPumpCalibrationInfo.iSysMasterListRev := 0;
		GVL_Calibration.stPumpCalibrationInfo.iSysSettingsRev := 0;
		GVL_Calibration.stPumpCalibrationInfo.iUserID := 'vd24';
		
		eStep := E_CalibStep.COMPLETE; 		
		
	E_CalibStep.CALBOX_ATTENTION:
    // Pause here while the operator adjusts the box weight on the scale.
    // No timeouts are running in this state.

    bBusy   := TRUE;
    sStatus := 'Calibration box weight out of range. Please fill to 1100–1300g and press Continue.';

    // Continue pressed on HMI?
    IF GVL_HMI.bCalBoxFixed THEN
        // Clear HMI flags
        GVL_HMI.bCalBoxNeedsAttention := FALSE;
        GVL_HMI.bCalBoxFixed := FALSE;

        bCalBoxAttention := FALSE;

        // Re-arm the same step to re-request a fresh weight
        bRequestWeight := TRUE;
        bWeightReady   := FALSE;

        // Return exactly where we paused (CHECKING_WEIGH)
        eStep := eStepResume;

		ELSIF bAbort THEN
			sStatus := 'Calibration aborted during calibration box attention.';
			eStep   := E_CalibStep.ERROR;
		END_IF	
		
	E_CalibStep.SCALE_ATTENTION:
		bBusy := TRUE;
		sStatus := 'Scale requires attention. Please fix on the device and press Continue.';
		// Wait for operator to press "Continue" (HMI toggles this)
		IF GVL_HMI.bScaleFixed THEN
			GVL_HMI.bScaleNeedsAtention := FALSE;
			GVL_HMI.bScaleFixed := FALSE;
			bScaleAttention := FALSE;
	
			// Re-arm reading for the same step
			bRequestWeight := TRUE;
			bWeightReady   := FALSE;
	
			// Resume exactly where we were
			eStep := eStepResume;
	
		ELSIF bAbort THEN
			sStatus := 'Calibration aborted during scale attention.';
			eStep := E_CalibStep.ERROR;
		END_IF
	
		
    E_CalibStep.COMPLETE:
        sStatus := 'Calibration Complete';
		iDataCount := iResultIndex - 1;
        bDone := TRUE;
        bBusy := FALSE;
        // Remains here till external reset
	
    E_CalibStep.ERROR:
        bBusy := FALSE;
        bDone := FALSE;
        sStatus := 'Calibration aborted due to error.';
        // Remains here till external reset

END_CASE]]></ST>
    </Implementation>
    <Method Name="Reset" Id="{c7d0a07f-1407-4f39-a43b-1c9fdbfdf587}">
      <Declaration><![CDATA[METHOD Reset : BOOL
VAR_INPUT
	bHard : BOOL := FALSE;
END_VAR
VAR
	iLocal : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// 1) Stop motion/actuators best-effort (ignore returns; repeated calls are safe)
IF (SIZEOF(GVL_Motion.aMotors) >= 3*SIZEOF(GVL_Motion.aMotors[1])) THEN
    GVL_Motion.aMotors[2].Stop();
    GVL_Motion.aMotors[3].Stop();
END_IF

FOR iLocal := 1 TO 10 DO
    GVL_Motion.aPumpsRotary[iLocal].Stop();
END_FOR

FOR iLocal := 1 TO 5 DO
    GVL_Motion.aValvesObj[iLocal].Stop();
END_FOR

GVL_Calibration.fbScaleDevice.Reset();

// 2) Disarm timers/edge detectors and clear triggers
tonCalDelay(IN := FALSE);
tonStepTimeout(IN := FALSE);
tonWeigthStabilization(IN := FALSE);
tonMotorsDelay(in := FALSE);

// Drop R_TRIG by passing CLK := FALSE this cycle
bExecutePulse(CLK := FALSE);

// 3) Clear internal flags and intermediate states
bStartCalibration     := FALSE;
bCalibrationRequested := FALSE;

bRequestWeight        := FALSE;
bWeightReady          := FALSE;

bMovePump             := FALSE;
bMoveMotorM2          := FALSE;
bMoveMotorM3          := FALSE;
FOR iLocal := 1 TO 5 DO
    bMoveValve[iLocal] := FALSE;
END_FOR

// 4) Reset indexes and temporaries
iPumpIndex    := 1;
iReplicate    := 0;
iResultIndex  := 1;

rWeightBefore := 0.0;
rWeightAfter  := 0.0;
rWeightDelta  := 0.0;
rVolume       := 0.0;
rScaleWeight  := 0.0;
rDistanceByVol:= 0.0;

// 5) Optional “hard” cleanup: clear selections and results
IF bHard THEN
    FOR iLocal := 1 TO 10 DO
        aPumpMask[iLocal]       := FALSE;
        aVolumeSetpoint[iLocal] := 0.0;
        aVelocity[iLocal]       := 0.0;
        aDirection[iLocal]      := E_PumpDirection.Forward; // default

        // Public result mirror (if you want a clean slate)
        aPumpResults[iLocal].eStatus        := E_CalibrationStatus.UNKNOWN;
        aPumpResults[iLocal].bAdjustment    := FALSE;
        aPumpResults[iLocal].bBusy          := FALSE;
        aPumpResults[iLocal].bSelected      := FALSE;
        aPumpResults[iLocal].iFailures      := 0;
        aPumpResults[iLocal].rActualVolume  := 0.0;
        aPumpResults[iLocal].rTargetVolume  := 0.0;
        aPumpResults[iLocal].tElapsed       := T#0S;
        aPumpResults[iLocal].tStartTime     := T#0S;

        // If you mirror HMI results elsewhere, clear here as needed.
    END_FOR
END_IF

// 6) Normalize outputs and step
bBusy   := FALSE;
bDone   := FALSE;
sStatus := 'Idle (reset)';
eStep   := E_CalibStep.IDLE;

// 7) Idempotent return
Reset := TRUE;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_CalibrationManager">
      <LineId Id="2779" Count="126" />
      <LineId Id="3414" Count="0" />
      <LineId Id="2910" Count="1" />
      <LineId Id="3415" Count="1" />
      <LineId Id="3418" Count="0" />
      <LineId Id="3417" Count="0" />
      <LineId Id="2912" Count="2" />
      <LineId Id="3413" Count="0" />
      <LineId Id="3412" Count="0" />
      <LineId Id="3419" Count="0" />
      <LineId Id="3411" Count="0" />
      <LineId Id="2915" Count="320" />
      <LineId Id="3422" Count="6" />
      <LineId Id="3421" Count="0" />
      <LineId Id="3242" Count="1" />
      <LineId Id="3431" Count="2" />
      <LineId Id="3430" Count="0" />
      <LineId Id="3244" Count="84" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_CalibrationManager.Reset">
      <LineId Id="189" Count="19" />
      <LineId Id="276" Count="0" />
      <LineId Id="209" Count="59" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>