<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_CalibrationManager" Id="{f5b6651e-f67d-465b-b243-425be4d72cd5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CalibrationManager
VAR_INPUT
    bExecute         : BOOL;
    bAbort           : BOOL;
    eSolvent         : E_SolventType;
    aPumpSettings    : ARRAY[1..10] OF ST_CalibrationPump;
    tDelayStart      : TIME;
    bPrintReport     : BOOL;
END_VAR

VAR_OUTPUT
    aPumpResults     : ARRAY[1..10] OF ST_CalibrationPump;
    bDone            : BOOL;
    bBusy            : BOOL;
    sStatus          : STRING;
END_VAR

VAR
    eStep            : E_CalibStep := E_CalibStep.IDLE;
    iPumpIndex       : INT := 1;
    iReplicate       : INT := 0;
    fbDelay          : TON;

    aPumpMask        : ARRAY[1..10] OF BOOL;
    aVolumeSetpoint  : ARRAY[1..10] OF REAL;
    aDirection       : ARRAY[1..10] OF E_PumpDirection;
    aVelocity        : ARRAY[1..10] OF REAL;

    fbPumps          : FB_AllPumpsController;
    fbScale          : FB_TCPClient;
    bTriggerScale    : BOOL := FALSE;

    rAcceptanceCrit  : REAL := 0.5;
    iAllowableFail   : INT := 2;
    iMaxReplicates   : INT := 2;
	
	i : USINT;
	rError : REAL;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE eStep OF

    E_CalibStep.IDLE:
        bBusy := FALSE;
        bDone := FALSE;
        sStatus := 'Idle';
        IF bExecute THEN
            fbDelay(IN := TRUE, PT := tDelayStart);
            bBusy := TRUE;
            iPumpIndex := 1;
            iReplicate := 0;
            eStep := E_CalibStep.DELAY;
        END_IF

    E_CalibStep.DELAY:
        sStatus := 'Waiting delay...';
        fbDelay(IN := TRUE);
        IF fbDelay.Q THEN
            eStep := E_CalibStep.START_PUMP;
        END_IF

    E_CalibStep.START_PUMP:
        IF aPumpSettings[iPumpIndex].bSelected THEN
            sStatus := CONCAT('Calibrating Pump ', INT_TO_STRING(iPumpIndex));

            FOR i := 1 TO 10 DO
                aPumpMask[i] := FALSE;
                aVolumeSetpoint[i] := 0.0;
                aVelocity[i] := 1.0;
                aDirection[i] := E_PumpDirection.FORWARD;
            END_FOR

            aPumpMask[iPumpIndex] := TRUE;
            aVolumeSetpoint[iPumpIndex] := aPumpSettings[iPumpIndex].rTargetVolume;

            fbPumps.MoveByVolume(
                aPumpIds := aPumpMask,
                aVolume := aVolumeSetpoint,
                aPumpDirection := aDirection,
                aVelocity := aVelocity
            );

            eStep := E_CalibStep.REQUEST_WEIGHT;
        ELSE
            eStep := E_CalibStep.NEXT_PUMP;
        END_IF

    E_CalibStep.REQUEST_WEIGHT:
        sStatus := 'Requesting weight from scale...';
        fbScale.sRemoteHost := '192.168.0.100';
        fbScale.nRemotePort := 10001;
        fbScale.bTrigger := TRUE;
        eStep := E_CalibStep.WAIT_WEIGHT;

    E_CalibStep.WAIT_WEIGHT:
        fbScale();
        IF fbScale.bConnectionDone AND NOT fbScale.bError THEN
            aPumpResults[iPumpIndex].rActualVolume := fbScale.fWeight; // peso em mL
            fbScale.bTrigger := FALSE;
            eStep := E_CalibStep.EVALUATE;
        ELSIF fbScale.bError THEN
            aPumpResults[iPumpIndex].eStatus := E_CalibrationStatus.FAILED;
            sStatus := 'Scale communication error';
            eStep := E_CalibStep.NEXT_PUMP;
        END_IF

    E_CalibStep.EVALUATE:
        rError := ABS(aPumpResults[iPumpIndex].rActualVolume - aPumpSettings[iPumpIndex].rTargetVolume) * 100.0 / aPumpSettings[iPumpIndex].rTargetVolume;

        IF rError <= rAcceptanceCrit THEN
            aPumpResults[iPumpIndex].eStatus := E_CalibrationStatus.PASSED;
            eStep := E_CalibStep.NEXT_PUMP;
        ELSE
            aPumpResults[iPumpIndex].iFailures := aPumpResults[iPumpIndex].iFailures + 1;
            aPumpResults[iPumpIndex].bAdjustment := TRUE;

            IF aPumpResults[iPumpIndex].iFailures > iAllowableFail THEN
                aPumpResults[iPumpIndex].eStatus := E_CalibrationStatus.FAILED;
                eStep := E_CalibStep.NEXT_PUMP;
            ELSE
                eStep := E_CalibStep.NEXT_REPLICATE;
            END_IF
        END_IF

    E_CalibStep.NEXT_REPLICATE:
        iReplicate := iReplicate + 1;
        IF iReplicate < iMaxReplicates THEN
            eStep := E_CalibStep.START_PUMP;
        ELSE
            eStep := E_CalibStep.NEXT_PUMP;
        END_IF

    E_CalibStep.NEXT_PUMP:
        iPumpIndex := iPumpIndex + 1;
        iReplicate := 0;
        IF iPumpIndex <= 10 THEN
            eStep := E_CalibStep.START_PUMP;
        ELSE
            eStep := E_CalibStep.COMPLETE;
        END_IF

    E_CalibStep.COMPLETE:
        sStatus := 'Calibration Completed';
        bDone := TRUE;
        bBusy := FALSE;
        eStep := E_CalibStep.IDLE;

END_CASE]]></ST>
    </Implementation>
    <LineIds Name="FB_CalibrationManager">
      <LineId Id="174" Count="66" />
      <LineId Id="242" Count="39" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>