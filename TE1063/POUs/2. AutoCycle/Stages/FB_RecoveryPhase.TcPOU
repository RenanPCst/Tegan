<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_RecoveryPhase" Id="{83f5ec5b-6c67-443f-8065-7a3e8ba1c7ee}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RecoveryPhase

VAR_INPUT
    bExecute : BOOL; 
END_VAR

VAR_OUTPUT
	bSuccess 		: BOOL;	//Success Flag
    bError 			: BOOL; //Error Flag
END_VAR

VAR
	eRecoveryState : E_RecoveryState := E_RecoveryState.Idle;

    fbSolenoidControl : FB_SolenoidControl;
	
	//Error Handle
	bErrorDetected   : BOOL := FALSE;
    nPumpWithError   : INT := 0;
    nErrorID         : UDINT := 0;

    iStepCounter : INT := 0;
    i : USINT; //loop for index

	// Control flags
	bStart		: BOOL := FALSE;
    bMoveM2 	: BOOL := FALSE;
	bMoveM3		: BOOL := FALSE;
    bMovementComplete : BOOL := FALSE;
	
	
	//Metering Rinse 1
	bMoveValveDone		 : ARRAY[1..5] OF BOOL;
	bMovePumpDone		 : ARRAY[1..10] OF BOOL;
	fDistance        	 : ARRAY[1..10] OF REAL;
	
	//Recirculate Solvent 1
    fAgitationTime   : REAL := 0;
	fCalcDistance	 : ARRAY[1..10] OF REAL;
	
	//Solvent Soak
	timerSoak       : TON;
    bTimerStarted   : BOOL := FALSE;
	bSoakTimerDone  : BOOL := FALSE;
	
	// Progress Bar Timing
	rTotalEstimatedTimeSec : REAL := 0.0;
	rElapsedTimeSec : REAL := 0.0;
	tStartTime : TIME := T#0S;
	bProgressInitDone : BOOL := FALSE;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bStart THEN
	eRecoveryState := E_RecoveryState.Idle;
	bStart := bExecute;
END_IF

IF bProgressInitDone AND (eRecoveryState <> E_RecoveryState.Idle) AND (eRecoveryState <> E_RecoveryState.Completed) THEN
	rElapsedTimeSec := TO_REAL(TIME() - tStartTime) / 1000.0; // convert to seconds

	GVL_HMI.HMIAnimation.rLoadBarRecovery := MIN(100.0, rElapsedTimeSec / rTotalEstimatedTimeSec * 100.0);
END_IF

CASE eRecoveryState OF

    E_RecoveryState.Idle:
		bSuccess := FALSE;
		bError := FALSE;
		
        IF bStart THEN
			//Start time calculation
			tStartTime := TIME();
			rTotalEstimatedTimeSec := EstimateTotalTime();
			bProgressInitDone := TRUE;
			//Provide HMI animation details
			GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Starting'; 
			GVL_HMI.HMIAnimation.rLoadBarRecovery  := 0;
			GVL_HMI.HMIAnimation.eIconStateRecovery := E_IconState.InProgress;
			//Move to next step
            eRecoveryState := E_RecoveryState.Metering_Solvent1;
        END_IF;

    E_RecoveryState.Metering_Solvent1:

        MeteringSolvent1(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Recirculate_Solvent1;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF


    E_RecoveryState.Recirculate_Solvent1:

        RecirculateSolvent1(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Solvent_Soak;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF

	
    E_RecoveryState.Solvent_Soak:

        SolventSoak(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF


    E_RecoveryState.Cleaning_Lines_S1:

        CleaningLinesSolvent1();
        IF bMovementComplete THEN
            IF GVL_Recipe.stActiveRecipe.stSolventsTimes.aSolventN[2] <> 0 THEN //check if two solvents is needed to recovery 
                eRecoveryState := E_RecoveryState.Metering_Solvent2;
				iStepCounter := 0;
            	bMovementComplete := FALSE;
            ELSE
                eRecoveryState := E_RecoveryState.Prime_Needles; // Skip to next applicable state
				iStepCounter := 0;
            	bMovementComplete := FALSE;
            END_IF
            bMovementComplete := FALSE;
        END_IF


    E_RecoveryState.Metering_Solvent2:

        MeteringSolvent2(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Mix_Solvent1_2;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF


    E_RecoveryState.Mix_Solvent1_2:

        MixSolvent1and2(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1_S2;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF

	
    E_RecoveryState.Cleaning_Lines_S1_S2:
	
        CleaningLinesSolvent1and2(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Prime_Needles;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	

    E_RecoveryState.Prime_Needles:
	
        PrimeNeedles(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Fill_Vials_Row_1;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	

    E_RecoveryState.Fill_Vials_Row_1:
	
        Fill_Vials_Row_1();
        IF bMovementComplete THEN
            IF GVL_Recipe.stCurrentRecipe.stOtherParams.iVialsToFill > 1 THEN //Check how many vials lines will be filled
                eRecoveryState := E_RecoveryState.Fill_Vials_Row_2;
            ELSE
                eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            END_IF
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	
		
    E_RecoveryState.Fill_Vials_Row_2:
	
        Fill_Vials_Row_2();
        IF bMovementComplete THEN
            IF GVL_Recipe.stCurrentRecipe.stOtherParams.iVialsToFill > 2 THEN //Check how many vials lines will be filled
                eRecoveryState := E_RecoveryState.Fill_Vials_Row_3;
            ELSE
                eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            END_IF
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	
	
	E_RecoveryState.Fill_Vials_Row_3:
	
        Fill_Vials_Row_3();
        IF bMovementComplete THEN
            IF GVL_Recipe.stCurrentRecipe.stOtherParams.iVialsToFill > 3 THEN //Check how many vials lines will be filled
                eRecoveryState := E_RecoveryState.Fill_Vials_Row_4;
            ELSE
                eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            END_IF
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	
	
	E_RecoveryState.Fill_Vials_Row_4:
	
        Fill_Vials_Row_4();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	

    E_RecoveryState.Waste_Remaining_Solvent:
	
        WasteRemainingSolvent();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Completed;
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF


    E_RecoveryState.Completed:
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Completed'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 100;
		GVL_HMI.HMIAnimation.eIconStateRecovery := E_IconState.Completed;
		bSuccess := TRUE;

END_CASE;
]]></ST>
    </Implementation>
    <Action Name="CleaningLinesSolvent1" Id="{9273111f-dd95-4702-809f-ba9c490b1159}">
      <Implementation>
        <ST><![CDATA[//Exactly the oppisite of Recirculate Solvent 1
CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Cleaning Lines R1'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 30;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 1

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] := fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [positive moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="CleaningLinesSolvent1and2" Id="{87b6bc97-2d34-4577-b9ae-634c57593673}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Cleaning Lines'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 60;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 2

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate2Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] 	:= fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Method Name="EstimateTotalTime" Id="{5a7388ad-dbe5-46cf-8db1-7675e96f6014}">
      <Declaration><![CDATA[METHOD PRIVATE EstimateTotalTime : REAL
VAR_INPUT
END_VAR
VAR
	i : INT;
	iRow : INT;
    rTotalTime : LREAL := 0.0;
    rMaxPumpTime : REAL;
    rTmpTime : REAL;
	aPumpVolume : ARRAY[1..10] OF REAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// --- MOTORS M2 and M3 ---
// Movements are sequential, so times are summed
rTotalTime := rTotalTime
    + (ABS(GVL_Settings.stMachineParam.aM2Position[3] - GVL_Settings.stMachineParam.aM2Position[1]) / GVL_Settings.stMachineParam.rM2Velocity) * 4
    + (ABS(GVL_Settings.stMachineParam.aM3Position[4] - GVL_Settings.stMachineParam.aM3Position[1]) / GVL_Settings.stMachineParam.rM3Velocity) * 4;

// --- VALVES ---
// Valves move in parallel, so estimate per group of 5 valves per switch
// Estimated 0.8s per position change, 8 total changes
rTotalTime := rTotalTime + 0.8 * 8;


// --- TIMERS ---
// Add the Agitation and Soak durations directly (in seconds)
rTotalTime := rTotalTime + TO_REAL(GVL_Recipe.stActiveRecipe.stOtherParams.tAgitate1Time) / 1000.0;
rTotalTime := rTotalTime + TO_REAL(GVL_Recipe.stActiveRecipe.stOtherParams.tAgitate2Time) / 1000.0;
rTotalTime := rTotalTime + TO_REAL(GVL_Recipe.stActiveRecipe.stOtherParams.tSoakTime) / 1000.0;


// --- PUMPS ---
// Pumps move in parallel. We always use the slowest pump as reference for each phase.

// Metering Solvent 1
rMaxPumpTime := 0;
aPumpVolume[1] := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[1] + 10;
aPumpVolume[2] := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[1] + 10;
aPumpVolume[3] := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[1] + 10;
aPumpVolume[4] := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[1] + 10;
aPumpVolume[5] := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[1] + 10;
aPumpVolume[6] := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[1] + 10;
aPumpVolume[7] := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[1] + 10;
aPumpVolume[8] := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[1] + 10;
aPumpVolume[9] := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[1] + 10;
aPumpVolume[10] := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[1] + 10;

FOR i := 1 TO 10 DO
    rTmpTime := F_VolumeToSteps(rVolume := aPumpVolume[i], iPumpIndex := i) / GVL_Motion.aPumps[i].Rotary.rSpeed;
    IF rTmpTime > rMaxPumpTime THEN rMaxPumpTime := rTmpTime; END_IF
END_FOR
rTotalTime := rTotalTime + rMaxPumpTime;

// Metering Solvent 2
rMaxPumpTime := 0;
aPumpVolume[1] := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[2] + 10;
aPumpVolume[2] := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[2] + 10;
aPumpVolume[3] := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[2] + 10;
aPumpVolume[4] := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[2] + 10;
aPumpVolume[5] := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[2] + 10;
aPumpVolume[6] := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[2] + 10;
aPumpVolume[7] := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[2] + 10;
aPumpVolume[8] := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[2] + 10;
aPumpVolume[9] := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[2] + 10;
aPumpVolume[10] := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[2] + 10;
FOR i := 1 TO 10 DO
    rTmpTime := F_VolumeToSteps(rVolume := aPumpVolume[i], iPumpIndex := i) / GVL_Motion.aPumps[i].Rotary.rSpeed;
    IF rTmpTime > rMaxPumpTime THEN rMaxPumpTime := rTmpTime; END_IF
END_FOR
rTotalTime := rTotalTime + rMaxPumpTime;

// Prime Needles
rMaxPumpTime := 0;
FOR i := 1 TO 10 DO
    rTmpTime := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + 20, iPumpIndex := i) / GVL_Motion.aPumps[i].Rotary.rSpeed;
    IF rTmpTime > rMaxPumpTime THEN rMaxPumpTime := rTmpTime; END_IF
END_FOR
rTotalTime := rTotalTime + rMaxPumpTime;

// Fill Vials Rows 1–4
FOR iRow := 1 TO GVL_Recipe.stActiveRecipe.stOtherParams.iVialsToFill DO
    rMaxPumpTime := 0;
    FOR i := 1 TO 10 DO
        IF iRow = 1 THEN
            rTmpTime := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := i) / GVL_Motion.aPumps[i].Rotary.rSpeed;
        ELSE
            rTmpTime := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := i) / GVL_Motion.aPumps[i].Rotary.rSpeed;
        END_IF
        IF rTmpTime > rMaxPumpTime THEN 
			rMaxPumpTime := rTmpTime; 
		END_IF
    END_FOR
    rTotalTime := rTotalTime + rMaxPumpTime;
END_FOR

// Waste Remaining Solvent
rMaxPumpTime := 0;

FOR i := 1 TO 10 DO
    rTmpTime := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[2], iPumpIndex := i) / GVL_Motion.aPumps[i].Rotary.rSpeed;
    IF rTmpTime > rMaxPumpTime THEN
 		rMaxPumpTime := rTmpTime; 
	END_IF
	
END_FOR
rTotalTime := rTotalTime + rMaxPumpTime;

EstimateTotalTime := rTotalTime + 180;]]></ST>
      </Implementation>
    </Method>
    <Action Name="Fill_Vials_Row_1" Id="{175ea493-1eff-4a16-bd97-613f6d5c4b1b}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Fill Vials R1'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 70;
		iStepCounter := 1;
		
    1: // Set Valves into position 6 - Needles
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE; // reset flags
        	END_FOR
        	iStepCounter := 2; //move to next step
		END_IF
		
	2: // M2 and M3 Motors movement
		IF NOT bMoveM3 THEN //Move M3 [Horizontal Motor] to vial line 1 position
			bMoveM3 := GVL_Motion.aMotors[3].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM3Position[2], //vial line 1
															rVelocity := GVL_Settings.stMachineParam.rM3Velocity,
															rAcc := GVL_Settings.stMachineParam.rM3Accleration, 
															rDec := GVL_Settings.stMachineParam.rM3Deceleration	
														 	);
		END_IF
		IF NOT bMoveM2 AND bMoveM3 THEN //Move M2 [Vertical Motor] to fill vials position after M3 movement is done
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[3], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 and M3 Movement is done, reset the flags and go to the next step
		IF bMoveM2 AND bMoveM3 THEN
			bMoveM2 := FALSE;
			bMoveM3 := FALSE;
			iStepCounter := 3;
		END_IF
 

    3: // Calculating distance for each pump
    	fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVial1FillVol, iPumpIndex := 10);
		
		iStepCounter := 4; // Move to next step
		
    4: // Start pumping by distance (degrees/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step
		END_IF

	5: //Reset M2 postion
		IF NOT bMoveM2 THEN //Move M2 [Vertical Motor] to Home Position
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[1], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 Movement is done, reset the flag and go to the next step
		IF bMoveM2 THEN
			bMoveM2 := FALSE;
			iStepCounter := 6;
		END_IF	
	
    6: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="Fill_Vials_Row_2" Id="{4d0f44b2-18a7-4986-9bc7-67bfa926fd0f}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Fill Vials R2'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 75;
		iStepCounter := 1;
		
    1: // Set Valves into position 6 - Needles
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE; // reset flags
        	END_FOR
        	iStepCounter := 2; //move to next step
		END_IF
		
	2: // M2 and M3 Motors movement
		IF NOT bMoveM3 THEN //Move M3 [Horizontal Motor] to vial line 1 position
			bMoveM3 := GVL_Motion.aMotors[3].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM3Position[3], //Vial line 2
															rVelocity := GVL_Settings.stMachineParam.rM3Velocity,
															rAcc := GVL_Settings.stMachineParam.rM3Accleration, 
															rDec := GVL_Settings.stMachineParam.rM3Deceleration	
														 	);
		END_IF
		IF NOT bMoveM2 AND bMoveM3 THEN //Move M2 [Vertical Motor] to fill vials position after M3 movement is done
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[3], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 and M3 Movement is done, reset the flags and go to the next step
		IF bMoveM2 AND bMoveM3 THEN
			bMoveM2 := FALSE;
			bMoveM3 := FALSE;
			iStepCounter := 3;
		END_IF
 

    3: // Calculating distance for each pump
    	fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 10);
		
		iStepCounter := 4; // Move to next step
		
    4: // Start pumping by distance (degrees/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		
		//Waits for every pump movement done flag
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step
		END_IF

	5: //Reset M2 postion
		IF NOT bMoveM2 THEN //Move M2 [Vertical Motor] to Home Position
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[1], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 Movement is done, reset the flag and go to the next step
		IF bMoveM2 THEN
			bMoveM2 := FALSE;
			iStepCounter := 6;
		END_IF	
	
    6: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="Fill_Vials_Row_3" Id="{64765b9d-3a6b-4f52-8a3a-ae25b14c22a3}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Fill Vials R3'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 80;
		iStepCounter := 1;
		
    1: // Set Valves into position 6 - Needles
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE; // reset flags
        	END_FOR
        	iStepCounter := 2; //move to next step
		END_IF
		
	2: // M2 and M3 Motors movement
		IF NOT bMoveM3 THEN //Move M3 [Horizontal Motor] to vial line 3 position
			bMoveM3 := GVL_Motion.aMotors[3].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM3Position[4], //Vial line 3
															rVelocity := GVL_Settings.stMachineParam.rM3Velocity,
															rAcc := GVL_Settings.stMachineParam.rM3Accleration, 
															rDec := GVL_Settings.stMachineParam.rM3Deceleration	
														 	);
		END_IF
		IF NOT bMoveM2 AND bMoveM3 THEN //Move M2 [Vertical Motor] to fill vials position after M3 movement is done
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[3], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 and M3 Movement is done, reset the flags and go to the next step
		IF bMoveM2 AND bMoveM3 THEN
			bMoveM2 := FALSE;
			bMoveM3 := FALSE;
			iStepCounter := 3;
		END_IF
 

    3: // Calculating distance for each pump
    	fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 10);
		
		iStepCounter := 4; // Move to next step
		
    4: // Start pumping by distance (degrees/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		
		//Waits for every pump movement done flag
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step
		END_IF

	5: //Reset M2 postion
		IF NOT bMoveM2 THEN //Move M2 [Vertical Motor] to Home Position
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[1], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 Movement is done, reset the flag and go to the next step
		IF bMoveM2 THEN
			bMoveM2 := FALSE;
			iStepCounter := 6;
		END_IF	
	
    6: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="Fill_Vials_Row_4" Id="{491460a0-4929-4ea4-bfa4-c7a25ac97b70}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Fill Vials R4'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 85;
		iStepCounter := 1;
		
    1: // Set Valves into position 6 - Needles
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE; // reset flags
        	END_FOR
        	iStepCounter := 2; //move to next step
		END_IF
		
	2: // M2 and M3 Motors movement
		IF NOT bMoveM3 THEN //Move M3 [Horizontal Motor] to vial line 3 position
			bMoveM3 := GVL_Motion.aMotors[3].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM3Position[5], //Vial line 4
															rVelocity := GVL_Settings.stMachineParam.rM3Velocity,
															rAcc := GVL_Settings.stMachineParam.rM3Accleration, 
															rDec := GVL_Settings.stMachineParam.rM3Deceleration	
														 	);
		END_IF
		IF NOT bMoveM2 AND bMoveM3 THEN //Move M2 [Vertical Motor] to fill vials position after M3 movement is done
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[3], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 and M3 Movement is done, reset the flags and go to the next step
		IF bMoveM2 AND bMoveM3 THEN
			bMoveM2 := FALSE;
			bMoveM3 := FALSE;
			iStepCounter := 3;
		END_IF
 

    3: // Calculating distance for each pump
    	fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVials2_4FillVol, iPumpIndex := 10);
		
		iStepCounter := 4; // Move to next step
		
    4: // Start pumping by distance (degrees/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		
		//Waits for every pump movement done flag
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step
		END_IF

	5: //Reset M2 postion
		IF NOT bMoveM2 THEN //Move M2 [Vertical Motor] to Home Position
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[1], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 Movement is done, reset the flag and go to the next step
		IF bMoveM2 THEN
			bMoveM2 := FALSE;
			iStepCounter := 6;
		END_IF	
	
    6: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Method Name="GetPumpVolume" Id="{92e83561-92ab-423b-96a0-648f72e2e29e}">
      <Declaration><![CDATA[METHOD PRIVATE GetPumpVolume : REAL
VAR_INPUT
	iPump : INT;  // Pump number 1..10
    iStep : INT;  // 1..4 [step Rinse 1 | Rinse 2 | Wash 1 | Wash 2] 
END_VAR
VAR
    volume : REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE iPump OF
    1: volume := GVL_Recipe.stVolumes.aT_IC_Volume[iStep];
    2: volume := GVL_Recipe.stVolumes.aS0_Volume[iStep];
    3: volume := GVL_Recipe.stVolumes.aS1_Volume[iStep];
    4: volume := GVL_Recipe.stVolumes.aS2_Volume[iStep];
    5: volume := GVL_Recipe.stVolumes.aS3_Volume[iStep];
    6: volume := GVL_Recipe.stVolumes.aS4_Volume[iStep];
    7: volume := GVL_Recipe.stVolumes.aS5_Volume[iStep];
    8: volume := GVL_Recipe.stVolumes.aS6_Volume[iStep];
    9: volume := GVL_Recipe.stVolumes.aS7_Volume[iStep];
    10: volume := GVL_Recipe.stVolumes.aF_Volume[iStep];
    ELSE
        volume := 0.0;
END_CASE

GetPumpVolume := volume;]]></ST>
      </Implementation>
    </Method>
    <Action Name="MeteringSolvent1" Id="{043bbe9a-a49a-4e9b-8157-9bfa39662a89}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Metering Rinse 1'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 10;
		iStepCounter := 1;
	
    1: // Initialization: Reset solenoids and set valves
        fbSolenoidControl(bExecute := TRUE, eSolenoidSet := E_SolenoidSet.IDLE);
		
		IF fbSolenoidControl.bDone THEN
			iStepCounter := 2;
		END_IF
		
    2: // Set valves for Rinse 1 position
	    FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
				bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve(iPosition := GVL_Recipe.stActiveRecipe.stSolventsTimes.aSolventN[1], 
																	 	rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 	rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 	rDec := GVL_Motion.aValves[i].rDeceleration 
																		);
			END_IF
			
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 3;
		END_IF
        
	3: //Calculating the distance for each pump
		fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[1] + GVL_Motion.aPumps[1].Rotary.rDeadVolume, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[1] + GVL_Motion.aPumps[2].Rotary.rDeadVolume, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[1] + GVL_Motion.aPumps[3].Rotary.rDeadVolume, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[1] + GVL_Motion.aPumps[4].Rotary.rDeadVolume, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[1] + GVL_Motion.aPumps[5].Rotary.rDeadVolume, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[1] + GVL_Motion.aPumps[6].Rotary.rDeadVolume, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[1] + GVL_Motion.aPumps[7].Rotary.rDeadVolume, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[1] + GVL_Motion.aPumps[8].Rotary.rDeadVolume, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[1] + GVL_Motion.aPumps[9].Rotary.rDeadVolume, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[1] + GVL_Motion.aPumps[10].Rotary.rDeadVolume, iPumpIndex := 10);
		
		iStepCounter := 4;
		
    4: // Performs rotary movement (positive movement)
        FOR i := 1 TO 10 DO
            IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fDistance[i],
																			 Velocity := GVL_Recipe.stActiveRecipe.stSolventsTimes.aVelocity[1] * 6, //GVL_Motion.aPumps[i].Rotary.rSpeed
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step to monitor completion
		END_IF
	
	5: // Sets the movement done flag
		bMovementComplete := TRUE;
         
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="MeteringSolvent2" Id="{ab3c9a64-fa5a-49bd-80d9-c7e2f0aaf572}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Metering Rinse 2'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 40;
		iStepCounter := 1;
	
    1: // Initialization: Reset solenoids and set valves
        fbSolenoidControl(bExecute := TRUE, eSolenoidSet := E_SolenoidSet.IDLE);
		
		IF fbSolenoidControl.bDone THEN
			iStepCounter := 2;
		END_IF
		
    2: // Set valves for Rinse 2 position
	    FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
				bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := GVL_Recipe.stActiveRecipe.stSolventsTimes.aSolventN[2], 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
			
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 3;
		END_IF
        
	3: //Calculating the distance for each pump
		fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[2] + GVL_Motion.aPumps[1].Rotary.rDeadVolume, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[2] + GVL_Motion.aPumps[2].Rotary.rDeadVolume, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[2] + GVL_Motion.aPumps[3].Rotary.rDeadVolume, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[2] + GVL_Motion.aPumps[4].Rotary.rDeadVolume, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[2] + GVL_Motion.aPumps[5].Rotary.rDeadVolume, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[2] + GVL_Motion.aPumps[6].Rotary.rDeadVolume, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[2] + GVL_Motion.aPumps[7].Rotary.rDeadVolume, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[2] + GVL_Motion.aPumps[8].Rotary.rDeadVolume, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[2] + GVL_Motion.aPumps[9].Rotary.rDeadVolume, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[2] + GVL_Motion.aPumps[10].Rotary.rDeadVolume, iPumpIndex := 10);
		
		iStepCounter := 4;
		
    4: // Performs rotary movement (positive movement)
        FOR i := 1 TO 10 DO
            IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fDistance[i],
																			 Velocity := GVL_Recipe.stActiveRecipe.stSolventsTimes.aVelocity[2] * 6, //GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step to monitor completion
		END_IF
	
	5: // Sets the movement done flag
		bMovementComplete := TRUE;
         
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="MixSolvent1and2" Id="{be5d325a-d90b-476e-8b7a-b5a6c59989fc}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Mix Solvents 1 and 2'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 50;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 2

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate2Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] 	:= fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="PrimeNeedles" Id="{40407892-18b3-49ae-adf9-38d07aae6967}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Prime Needles'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 65;
		iStepCounter := 1;
	
    1: // Set valves for Needles position
	    FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
				bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
			
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF
        
	2: //Calculating the distance for each pump
		fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[1].Rotary.rDeadVolume, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[2].Rotary.rDeadVolume, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[3].Rotary.rDeadVolume, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[4].Rotary.rDeadVolume, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[5].Rotary.rDeadVolume, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[6].Rotary.rDeadVolume, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[7].Rotary.rDeadVolume, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[8].Rotary.rDeadVolume, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[9].Rotary.rDeadVolume, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol + GVL_Motion.aPumps[10].Rotary.rDeadVolume, iPumpIndex := 10);
		
		iStepCounter := 3;
		
    3: // Performs rotary movement (positive movement)
        FOR i := 1 TO 10 DO
            IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fDistance[i],
																			 Velocity := GVL_Recipe.stActiveRecipe.stSolventsTimes.aVelocity[1] * 6, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF
	
	4: // Sets the movement done flag
		bMovementComplete := TRUE;
         
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="RecirculateSolvent1" Id="{dd88b683-a3d6-421a-a9d9-04dab5a1112d}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Recirculate Solvent'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 20;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 1

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] 	:= fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed,
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Method Name="Reset" Id="{12eefff6-07c0-42e5-ab61-91712c03c502}">
      <Declaration><![CDATA[METHOD Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Init Flags
nPumpWithError  := 0;
nErrorID   		:= 0;
iStepCounter 	:= 0;
eRecoveryState := E_RecoveryState.Idle;

//Output flags
bSuccess := FALSE;
bError := FALSE;

// Control flags
bStart := FALSE;
bMovementComplete := FALSE;

//Recirculate Solvent 1
fAgitationTime    	:= 0;

FOR i := 1 TO 10 DO
	fCalcDistance[i] := 0;
	fDistance[i] := 0;
END_FOR

//Solvent Soak
bTimerStarted   := FALSE;
bSoakTimerDone  := FALSE;

//Icon progress reset
GVL_HMI.HMIAnimation.eIconStateLeakTest := E_IconState.Waiting;
GVL_HMI.HMIAnimation.eIconStateRecovery := E_IconState.Waiting;
GVL_HMI.HMIAnimation.rLoadBarLeakTest := 0;
GVL_HMI.HMIAnimation.rLoadBarRecovery := 0;

tStartTime := T#0S;
rElapsedTimeSec := 0.0;
rTotalEstimatedTimeSec := 0.0;
bProgressInitDone := FALSE;
GVL_HMI.HMIAnimation.rLoadBarRecovery := 0.0;

IF NOT bSuccess AND NOT bError THEN
	Reset := TRUE;
	RETURN;
ELSE
	Reset := FALSE;
END_IF

	

	]]></ST>
      </Implementation>
    </Method>
    <Action Name="SolventSoak" Id="{024c621c-c960-47f6-8737-9a73b1607501}">
      <Implementation>
        <ST><![CDATA[//Provide HMI animation details
GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Solvent Soak'; 
//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 30;

// Initialize the Soak timer
bTimerStarted := TRUE;

IF timerSoak.Q THEN
	// Time completed, reset the timer
	bTimerStarted := FALSE;
	bSoakTimerDone := TRUE;
END_IF

// Wait for the timer to complete the time
timerSoak(IN := bTimerStarted, PT := GVL_Recipe.stActiveRecipe.stOtherParams.tSoakTime);

IF bSoakTimerDone THEN
	// Marks the end of the action
	bMovementComplete := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Action>
    <Action Name="WasteRemainingSolvent" Id="{a506e020-7a9f-47c0-ade1-266bb776f9c2}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Waste Solvent'; 
		//GVL_HMI.HMIAnimation.rLoadBarRecovery  := 90;
		iStepCounter := 1;
		
    1: // Set Valves into position 6 - Needles
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE; // reset flags
        	END_FOR
        	iStepCounter := 2; //move to next step
		END_IF
		
	2: // M3 Motors movement

		IF NOT bMoveM3 THEN //Move M3 [Horizontal Motor] to Home Position to waste solvent left
			bMoveM3 := GVL_Motion.aMotors[3].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM3Position[1], //Home Position
															rVelocity := GVL_Settings.stMachineParam.rM3Velocity,
															rAcc := GVL_Settings.stMachineParam.rM3Accleration, 
															rDec := GVL_Settings.stMachineParam.rM3Deceleration	
														 	);
		END_IF
		
		IF NOT bMoveM2 AND bMoveM3 THEN //Move M2 [Vertical Motor] to fill vials position after M3 movement is done
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[2], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		
		// If M2 and M3 Movement is done, reset the flags and go to the next step
		IF bMoveM2 AND bMoveM3 THEN
			bMoveM2 := FALSE;
			bMoveM3 := FALSE;
			iStepCounter := 3;
		END_IF
		
    3: // Calculating distance for each pump
    	fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[2], iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[2], iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[2], iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[2], iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[2], iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[2], iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[2], iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[2], iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[2], iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[1] + GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[2], iPumpIndex := 10);
		
		iStepCounter := 4; // Move to next step
		
    4: // Start pumping by distance (degrees/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		
		//Waits for every pump movement done flag
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step
		END_IF

	5: //Resets M2 position
		IF NOT bMoveM2 THEN //Move M2 [Vertical Motor] to fill vials position after M3 movement is done
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM2Position[1], 
															rVelocity := GVL_Settings.stMachineParam.rM2Velocity,
															rAcc := GVL_Settings.stMachineParam.rM2Accleration, 
															rDec := GVL_Settings.stMachineParam.rM2Deceleration	
														 	);
		END_IF
		IF bMoveM2 THEN
			bMoveM2 := FALSE;
			iStepCounter := 6;
		END_IF
	
		
    6: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_RecoveryPhase">
      <LineId Id="851" Count="0" />
      <LineId Id="1191" Count="0" />
      <LineId Id="1209" Count="0" />
      <LineId Id="854" Count="0" />
      <LineId Id="1213" Count="4" />
      <LineId Id="1212" Count="0" />
      <LineId Id="855" Count="3" />
      <LineId Id="1285" Count="1" />
      <LineId Id="868" Count="1" />
      <LineId Id="1297" Count="0" />
      <LineId Id="1295" Count="1" />
      <LineId Id="1294" Count="0" />
      <LineId Id="1288" Count="2" />
      <LineId Id="1287" Count="0" />
      <LineId Id="1292" Count="0" />
      <LineId Id="870" Count="0" />
      <LineId Id="872" Count="102" />
      <LineId Id="1008" Count="11" />
      <LineId Id="981" Count="0" />
      <LineId Id="1020" Count="0" />
      <LineId Id="1022" Count="11" />
      <LineId Id="1021" Count="0" />
      <LineId Id="1034" Count="0" />
      <LineId Id="1036" Count="3" />
      <LineId Id="1043" Count="0" />
      <LineId Id="1045" Count="2" />
      <LineId Id="1035" Count="0" />
      <LineId Id="982" Count="0" />
      <LineId Id="991" Count="0" />
      <LineId Id="1048" Count="0" />
      <LineId Id="992" Count="5" />
      <LineId Id="1049" Count="0" />
      <LineId Id="998" Count="1" />
      <LineId Id="1051" Count="1" />
      <LineId Id="1182" Count="0" />
      <LineId Id="1118" Count="0" />
      <LineId Id="1006" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1">
      <LineId Id="207" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="153" Count="25" />
      <LineId Id="208" Count="2" />
      <LineId Id="179" Count="26" />
      <LineId Id="150" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1and2">
      <LineId Id="2" Count="56" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.EstimateTotalTime">
      <LineId Id="57" Count="23" />
      <LineId Id="146" Count="0" />
      <LineId Id="150" Count="8" />
      <LineId Id="147" Count="0" />
      <LineId Id="81" Count="7" />
      <LineId Id="160" Count="8" />
      <LineId Id="159" Count="0" />
      <LineId Id="89" Count="23" />
      <LineId Id="129" Count="1" />
      <LineId Id="113" Count="5" />
      <LineId Id="134" Count="0" />
      <LineId Id="119" Count="1" />
      <LineId Id="124" Count="0" />
      <LineId Id="131" Count="2" />
      <LineId Id="125" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_1">
      <LineId Id="2" Count="23" />
      <LineId Id="59" Count="2" />
      <LineId Id="63" Count="0" />
      <LineId Id="65" Count="3" />
      <LineId Id="64" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="73" Count="2" />
      <LineId Id="70" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="80" Count="2" />
      <LineId Id="79" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="84" Count="7" />
      <LineId Id="93" Count="0" />
      <LineId Id="97" Count="1" />
      <LineId Id="37" Count="16" />
      <LineId Id="99" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="105" Count="5" />
      <LineId Id="104" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="112" Count="2" />
      <LineId Id="116" Count="1" />
      <LineId Id="103" Count="0" />
      <LineId Id="55" Count="3" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_2">
      <LineId Id="92" Count="72" />
      <LineId Id="191" Count="1" />
      <LineId Id="165" Count="25" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_3">
      <LineId Id="2" Count="100" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_4">
      <LineId Id="2" Count="100" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.GetPumpVolume">
      <LineId Id="10" Count="14" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent1">
      <LineId Id="216" Count="0" />
      <LineId Id="3" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="219" Count="2" />
      <LineId Id="218" Count="0" />
      <LineId Id="4" Count="2" />
      <LineId Id="204" Count="2" />
      <LineId Id="208" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="244" Count="3" />
      <LineId Id="242" Count="1" />
      <LineId Id="212" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="189" Count="1" />
      <LineId Id="188" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="222" Count="1" />
      <LineId Id="225" Count="5" />
      <LineId Id="232" Count="2" />
      <LineId Id="236" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="237" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="239" Count="0" />
      <LineId Id="192" Count="2" />
      <LineId Id="213" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="196" Count="4" />
      <LineId Id="195" Count="0" />
      <LineId Id="201" Count="2" />
      <LineId Id="72" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent2">
      <LineId Id="85" Count="67" />
      <LineId Id="84" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MixSolvent1and2">
      <LineId Id="88" Count="26" />
      <LineId Id="143" Count="6" />
      <LineId Id="120" Count="22" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.PrimeNeedles">
      <LineId Id="2" Count="6" />
      <LineId Id="16" Count="53" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.RecirculateSolvent1">
      <LineId Id="152" Count="1" />
      <LineId Id="275" Count="1" />
      <LineId Id="274" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="277" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="239" Count="4" />
      <LineId Id="282" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="283" Count="0" />
      <LineId Id="246" Count="4" />
      <LineId Id="161" Count="2" />
      <LineId Id="251" Count="1" />
      <LineId Id="285" Count="2" />
      <LineId Id="255" Count="0" />
      <LineId Id="257" Count="2" />
      <LineId Id="253" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="261" Count="4" />
      <LineId Id="280" Count="0" />
      <LineId Id="266" Count="5" />
      <LineId Id="192" Count="2" />
      <LineId Id="272" Count="1" />
      <LineId Id="225" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Reset">
      <LineId Id="56" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="73" Count="2" />
      <LineId Id="23" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="24" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="38" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="66" Count="1" />
      <LineId Id="77" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="46" Count="2" />
      <LineId Id="83" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="87" Count="3" />
      <LineId Id="85" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="63" Count="2" />
      <LineId Id="62" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.SolventSoak">
      <LineId Id="33" Count="3" />
      <LineId Id="4" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="12" Count="2" />
      <LineId Id="16" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.WasteRemainingSolvent">
      <LineId Id="2" Count="25" />
      <LineId Id="105" Count="0" />
      <LineId Id="28" Count="6" />
      <LineId Id="103" Count="0" />
      <LineId Id="110" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="119" Count="4" />
      <LineId Id="50" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="51" Count="31" />
      <LineId Id="124" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="128" Count="5" />
      <LineId Id="127" Count="0" />
      <LineId Id="135" Count="1" />
      <LineId Id="138" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="125" Count="1" />
      <LineId Id="99" Count="3" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>