<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_RecoveryPhase" Id="{83f5ec5b-6c67-443f-8065-7a3e8ba1c7ee}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RecoveryPhase

VAR_INPUT
    bExecute : BOOL; 
END_VAR

VAR_OUTPUT
	bSuccess 		: BOOL;	//Success Flag
    bError 			: BOOL; //Error Flag
    
END_VAR

VAR
	eRecoveryState : E_RecoveryState := E_RecoveryState.Idle;
    bInitComplete : BOOL := FALSE;

    fbSolenoidControl : FB_SolenoidControl;
	
	//Error Handle
	bErrorDetected   : BOOL := FALSE;
    nPumpWithError   : INT := 0;
    nErrorID         : UDINT := 0;

    iStepCounter : INT := 0;
    i : USINT; //loop for index
	
	//Timers
	timerAgitate : TON;
	// Control flags
	bStart		: BOOL := FALSE;
	bDone		: BOOL := FALSE;
	bReset		: BOOL := FALSE;
    bMoveServo 	: BOOL := TRUE;
    bMovementComplete : BOOL := FALSE;
	
	//Metering Rinse 1
	bMoveValveDone		 : ARRAY[1..5] OF BOOL;
    bAllValvesInPosition : BOOL := TRUE;
    bAllPumpsDone        : BOOL := TRUE;
	bMoveValvesDone		 : ARRAY[1..5] OF BOOL;
	
	//Recirculate Solvent 1
	bAllValvesInPos  : BOOL := FALSE;
    bMovementStarted : BOOL := FALSE;
    fDistance        : REAL := 0;
    fAgitationTime   : REAL := 0;
	fCalcDistance	 : REAL := 0;
    fVelocity        : REAL := 100; // Standard Velocity
	
	//Solvent Soak
	timerSoak       : TON;
    bTimerStarted   : BOOL := FALSE;
	
	//Metering Rinse 2
	

	
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE eRecoveryState OF

    E_RecoveryState.Idle:
		bDone := FALSE;

		IF bReset THEN
			ResetAll(); // Reset All Action.
		END_IF
	
        IF bStart THEN
            eRecoveryState := E_RecoveryState.Metering_Solvent1;
            bInitComplete := FALSE;
        END_IF;

    E_RecoveryState.Metering_Solvent1:
        MeteringSolvent1(); //Action
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Recirculate_Solvent1;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Recirculate_Solvent1:
        RecirculateSolvent1();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Solvent_Soak;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Solvent_Soak:
        SolventSoak();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Cleaning_Lines_S1:
        CleaningLinesSolvent1();
        IF bMovementComplete THEN
            IF GVL_Recipe.stSolventNTimes.aSolventN[2] <> 0 THEN
                eRecoveryState := E_RecoveryState.Metering_Solvent2;
            ELSE
                eRecoveryState := E_RecoveryState.Cleaning_Lines_S1_S2; // Skip to next applicable state
            END_IF;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Metering_Solvent2:
        MeteringSolvent2();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Mix_Solvent1_2;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Mix_Solvent1_2:
        MixSolvent1and2();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1_S2;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Cleaning_Lines_S1_S2:
        CleaningLinesSolvent1and2();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Prime_Needles;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Prime_Needles:
        PrimeNeedles();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Move_to_Position1;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Move_to_Position1:
        MoveToPosition();
        IF bMovementComplete THEN
            IF GVL_Recipe.stOtherParams.iVialsToFill > 1 THEN
                eRecoveryState := E_RecoveryState.Fill_Vials;
            ELSE
                eRecoveryState := E_RecoveryState.Move_To_Waste;
            END_IF;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Fill_Vials:
        FillAdditionalVials();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Move_To_Waste;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Move_To_Waste:
        MoveToWastePosition();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Dispose_Remaining_Solvent;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Dispose_Remaining_Solvent:
        DisposeRemainingSolvent();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Completed;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Completed:
        bDone := TRUE;
        IF bReset THEN
            eRecoveryState := E_RecoveryState.Idle;
            bDone := FALSE;
        END_IF;

END_CASE;
]]></ST>
    </Implementation>
    <Action Name="CleaningLinesSolvent1" Id="{9273111f-dd95-4702-809f-ba9c490b1159}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
(*
    0: // Inicia movimento reverse (negativo) para retornar solvente para as jarras
        FOR i := 1 TO 10 DO
            fbPumpRotary[i](
                Execute := TRUE,
                Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 1), iPumpIndex := i), // negativo = reverse
                Velocity := GVL_Recipe .stSolventNTimes.aVelocity[1],
                Axis := GVL_Motion.aPumps[i].Rotary.Axis);
        END_FOR

        bMovementStarted := TRUE;
        iStepCounter := 1;

    1: // Aguarda término do movimento das bombas
        IF bMovementStarted THEN
            bAllPumpsDone := TRUE;

            FOR i := 1 TO 10 DO
                fbPumpRotary[i](
                    Execute := TRUE,
                    Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 1), iPumpIndex := i),
                    Velocity := GVL_Recipe.stSolventNTimes.aVelocity[1],
                    Axis := GVL_Motion.aPumps[i].Rotary.Axis);

                IF fbPumpRotary[i].Error THEN
                    // Opcional: tratamento de erro aqui
                    bAllPumpsDone := FALSE;
                    iStepCounter := 999; // Estado de erro opcional
                ELSIF NOT fbPumpRotary[i].Done THEN
                    bAllPumpsDone := FALSE;
                END_IF
            END_FOR

            IF bAllPumpsDone THEN
                // Reset dos FBs após concluir movimento
                FOR i := 1 TO 10 DO
                    fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
                END_FOR

                bMovementStarted := FALSE;
                bMovementComplete := TRUE;
                iStepCounter := 0; // reset para próximo uso
            END_IF
        END_IF
*)
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="CleaningLinesSolvent1and2" Id="{87b6bc97-2d34-4577-b9ae-634c57593673}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="DisposeRemainingSolvent" Id="{a506e020-7a9f-47c0-ade1-266bb776f9c2}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="FillAdditionalVials" Id="{d24df81f-3d3e-477c-843f-8d6a95d22a6d}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Method Name="GetPumpVolume" Id="{92e83561-92ab-423b-96a0-648f72e2e29e}">
      <Declaration><![CDATA[METHOD PRIVATE GetPumpVolume : REAL
VAR_INPUT
	iPump : INT;  // Pump number 1..10
    iStep : INT;  // 1..4 [step Rinse 1 | Rinse 2 | Wash 1 | Wash 2] 
END_VAR
VAR
    volume : REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE iPump OF
    1: volume := GVL_Recipe.stVolumes.aT_IC_Volume[iStep];
    2: volume := GVL_Recipe.stVolumes.aS0_Volume[iStep];
    3: volume := GVL_Recipe.stVolumes.aS1_Volume[iStep];
    4: volume := GVL_Recipe.stVolumes.aS2_Volume[iStep];
    5: volume := GVL_Recipe.stVolumes.aS3_Volume[iStep];
    6: volume := GVL_Recipe.stVolumes.aS4_Volume[iStep];
    7: volume := GVL_Recipe.stVolumes.aS5_Volume[iStep];
    8: volume := GVL_Recipe.stVolumes.aS6_Volume[iStep];
    9: volume := GVL_Recipe.stVolumes.aS7_Volume[iStep];
    10: volume := GVL_Recipe.stVolumes.aF_Volume[iStep];
    ELSE
        volume := 0.0;
END_CASE

GetPumpVolume := volume;]]></ST>
      </Implementation>
    </Method>
    <Action Name="MeteringSolvent1" Id="{043bbe9a-a49a-4e9b-8157-9bfa39662a89}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF

    0: // Initialization: Reset solenoids and set valves
        fbSolenoidControl(bExecute := TRUE, eSolenoidSet := E_SolenoidSet.IDLE);

        FOR i := 1 TO 5 DO
			bMoveValveDone[i] := NOT GVL_Motion.aValvesObj[i].MoveValve(iValveID := i, iPosition := GVL_Recipe.stActiveRecipe.stSolventsTimes.aSolventN[1], rVelocity := 10, rAcc := 10, rDec := 10);
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
        	iStepCounter := 1;
		END_IF
(*
    1: // Wait for valve positioning
        bAllValvesInPosition := TRUE;
        FOR i := 1 TO 5 DO
            aValveController[i](
                bEnable := TRUE, 
                ServoAxis := GVL_Motion.aValves[i].Axis, 
                iValvePosition := GVL_Recipe.stSolventNTimes.aSolventN[1]);

            IF NOT aValveController[i].bMoveDone THEN
                bAllValvesInPosition := FALSE;
            END_IF
        END_FOR

        IF bAllValvesInPosition THEN
            iStepCounter := 2;
        END_IF

    2: // Move linear actuator of pumps (9mm opening)
        FOR i := 1 TO 10 DO
            fbPumpLinear[i](
                Execute := TRUE, 
                Position := 9.0, 
                Velocity := 5.0, 
                Axis := GVL_Motion.aPumps[i].Linear.Axis);
        END_FOR
        iStepCounter := 3;

    3: // Wait for complete linear movement
        bAllPumpsDone := TRUE;
        FOR i := 1 TO 10 DO
            fbPumpLinear[i](
                Execute := TRUE, 
                Position := 9.0, 
                Velocity := 5.0, 
                Axis := GVL_Motion.aPumps[i].Linear.Axis);

            IF NOT fbPumpLinear[i].Done THEN
                bAllPumpsDone := FALSE;
            END_IF
        END_FOR

        IF bAllPumpsDone THEN
            iStepCounter := 4;
        END_IF

    4: // Performs rotary movement (Volume in reverse - negative)
        FOR i := 1 TO 10 DO
            fbPumpRotary[i](
                Execute := TRUE, 
                Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 1), iPumpIndex := i), 
                Velocity := 100, 
                Axis := GVL_Motion.aPumps[i].Rotary.Axis);
        END_FOR
        iStepCounter := 5; // Move to next step to monitor completion

         


	5: // Aguarda conclusão ou detecta erro
    bAllPumpsDone := TRUE;

    FOR i := 1 TO 10 DO
        fbPumpRotary[i](
            Execute := TRUE,
            Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 1), iPumpIndex := i),
            Velocity := 100,
            Axis := GVL_Motion.aPumps[i].Rotary.Axis);

        IF fbPumpRotary[i].Error THEN
            bErrorDetected := TRUE;
            nPumpWithError := i;
            nErrorID := fbPumpRotary[i].ErrorID;
        END_IF

        IF NOT fbPumpRotary[i].Done THEN
            bAllPumpsDone := FALSE;
        END_IF
    END_FOR

    IF bErrorDetected THEN
        iStepCounter := 999; // Estado de erro
    ELSIF bAllPumpsDone THEN
        FOR i := 1 TO 10 DO
            fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
        END_FOR

        bMovementComplete := TRUE;
        iStepCounter := 0; // Reset normal
    END_IF

	999: // Estado de erro detectado
    // Reset seguro dos movimentos
    FOR i := 1 TO 10 DO
        fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
        fbPumpLinear[i](Execute := FALSE, Position := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Linear.Axis);
    END_FOR

    // Indicar alarme para HMI
    //GVL_Alarm.bPumpError := TRUE;
    //GVL_Alarm.nPumpErrorID := nErrorID;
    //GVL_Alarm.nPumpIndex := nPumpWithError;

    IF bReset THEN
        bErrorDetected := FALSE;
        //GVL_Alarm.bPumpError := FALSE;
        iStepCounter := 0; // Reset e tenta novamente
    END_IF

*)
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="MeteringSolvent2" Id="{ab3c9a64-fa5a-49bd-80d9-c7e2f0aaf572}">
      <Implementation>
        <ST><![CDATA[(*
IF GVL_Recipe.stSolventNTimes.aSolventN[2] = 0 THEN
    // Solvent 2 não definido, pula etapa diretamente
    bMovementComplete := TRUE;
    iStepCounter := 0;
ELSE

    CASE iStepCounter OF

        0: // Posicionar válvulas no solvente número 2
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := GVL_Recipe.stSolventNTimes.aSolventN[2]);
            END_FOR

            iStepCounter := 1;

        1: // Aguarda posicionamento das válvulas
            bAllValvesInPos := TRUE;
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := GVL_Recipe.stSolventNTimes.aSolventN[2]);

                IF NOT aValveController[i].bMoveDone THEN
                    bAllValvesInPos := FALSE;
                END_IF
            END_FOR

            IF bAllValvesInPos THEN
                iStepCounter := 2;
            END_IF

        2: // Movimentar atuador rotativo das bombas (sentido negativo/reverse)
            FOR i := 1 TO 10 DO
                fbPumpRotary[i](
                    Execute := TRUE,
                    Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 2), iPumpIndex := i), // negativo
                    Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                    Axis := GVL_Motion.aPumps[i].Rotary.Axis);
            END_FOR

            bMovementStarted := TRUE;
            iStepCounter := 3;

        3: // Aguarda término do movimento das bombas
            IF bMovementStarted THEN
                bAllPumpsDone := TRUE;

                FOR i := 1 TO 10 DO
                    fbPumpRotary[i](
                        Execute := TRUE,
                        Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 2), iPumpIndex := i),
                        Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                        Axis := GVL_Motion.aPumps[i].Rotary.Axis);

                    IF fbPumpRotary[i].Error THEN
                        // Opcional: tratamento de erro
                        bAllPumpsDone := FALSE;
                        iStepCounter := 999; // estado de erro opcional
                    ELSIF NOT fbPumpRotary[i].Done THEN
                        bAllPumpsDone := FALSE;
                    END_IF
                END_FOR

                IF bAllPumpsDone THEN
                    // Reset dos FBs
                    FOR i := 1 TO 10 DO
                        fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
                    END_FOR

                    bMovementStarted := FALSE;
                    bMovementComplete := TRUE;
                    iStepCounter := 0; // reset para próximo uso
                END_IF
            END_IF

    END_CASE

END_IF
*)]]></ST>
      </Implementation>
    </Action>
    <Action Name="MixSolvent1and2" Id="{be5d325a-d90b-476e-8b7a-b5a6c59989fc}">
      <Implementation>
        <ST><![CDATA[(*
IF GVL_Recipe.stSolventNTimes.aSolventN[2] = 0 THEN
    // Solvent 2 não definido, pula essa etapa diretamente
    bMovementComplete := TRUE;
    iStepCounter := 0;
ELSE

    CASE iStepCounter OF

        0: // Posicionar válvulas na posição 5 (recirculação)
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := 5);
            END_FOR

            iStepCounter := 1;

        1: // Aguarda posicionamento das válvulas
            bAllValvesInPos := TRUE;
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := 5);

                IF NOT aValveController[i].bMoveDone THEN
                    bAllValvesInPos := FALSE;
                END_IF
            END_FOR

            IF bAllValvesInPos THEN
                iStepCounter := 2;
            END_IF

        2: // Inicia movimento forward das bombas para misturar solventes
            FOR i := 1 TO 10 DO
                fCalcDistance := (GVL_Recipe.stSolventNTimes.aVelocity[2] * TIME_TO_REAL(GVL_Recipe.stOtherParams.tAgitate2Time)) / 1.8;

                fbPumpRotary[i](
                    Execute := TRUE,
                    Distance := fCalcDistance, // positivo = forward
                    Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                    Axis := GVL_Motion.aPumps[i].Rotary.Axis);
            END_FOR

            bMovementStarted := TRUE;
            iStepCounter := 3;

        3: // Aguarda término do movimento de mistura das bombas
            IF bMovementStarted THEN
                bAllPumpsDone := TRUE;

                FOR i := 1 TO 10 DO
                    fbPumpRotary[i](
                        Execute := TRUE,
                        Distance := (GVL_Recipe.stSolventNTimes.aVelocity[2] * TIME_TO_REAL(GVL_Recipe.stOtherParams.tAgitate2Time)) / 1.8,
                        Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                        Axis := GVL_Motion.aPumps[i].Rotary.Axis);

                    IF fbPumpRotary[i].Error THEN
                        // Opcional: tratamento de erro
                        bAllPumpsDone := FALSE;
                        iStepCounter := 999; // estado de erro opcional
                    ELSIF NOT fbPumpRotary[i].Done THEN
                        bAllPumpsDone := FALSE;
                    END_IF
                END_FOR

                IF bAllPumpsDone THEN
                    // Reset dos FBs
                    FOR i := 1 TO 10 DO
                        fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
                    END_FOR

                    bMovementStarted := FALSE;
                    bMovementComplete := TRUE;
                    iStepCounter := 0; // reset para próximo uso
                END_IF
            END_IF

    END_CASE

END_IF
*)]]></ST>
      </Implementation>
    </Action>
    <Action Name="MoveToPosition" Id="{e91bc937-13f8-4d14-a3d2-4237e5f04640}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="MoveToWastePosition" Id="{0d088b26-2d05-4186-b5b4-abd253dadf13}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="PrimeNeedles" Id="{40407892-18b3-49ae-adf9-38d07aae6967}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="RecirculateSolvent1" Id="{dd88b683-a3d6-421a-a9d9-04dab5a1112d}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
(*
    0: // Setar válvulas para posição 5 (Recirculação)
        FOR i := 1 TO 5 DO
            aValveController[i](
                bEnable := TRUE,
                ServoAxis := GVL_Motion.aValves[i].Axis,
                iValvePosition := 5);
        END_FOR
        iStepCounter := 1;

    1: // Aguarda posicionamento das válvulas
        bAllValvesInPos := TRUE;
        FOR i := 1 TO 5 DO
            aValveController[i](
                bEnable := TRUE,
                ServoAxis := GVL_Motion.aValves[i].Axis,
                iValvePosition := 5);

            IF NOT aValveController[i].bMoveDone THEN
                bAllValvesInPos := FALSE;
            END_IF
        END_FOR

        IF bAllValvesInPos THEN
            iStepCounter := 2;
        END_IF

    2: // Inicia movimento rotativo com distância calculada (graus/seg -> steps)
        FOR i := 1 TO 10 DO
            fCalcDistance := (GVL_Recipe.stSolventNTimes.aVelocity[1] * TIME_TO_REAL(GVL_Recipe.stOtherParams.tAgitate1Time)) / 1.8;

            fbPumpRotary[i](
                Execute := TRUE,
                Distance := fCalcDistance, // Forward (positivo)
                Velocity := GVL_Recipe.stSolventNTimes.aVelocity[1], // em graus/segundo
                Axis := GVL_Motion.aPumps[i].Rotary.Axis);
        END_FOR

        bMovementStarted := TRUE;
        iStepCounter := 3;

    3: // Aguarda término dos movimentos
        IF bMovementStarted THEN
            bAllPumpsDone := TRUE;

            FOR i := 1 TO 10 DO
                fbPumpRotary[i](
                    Execute := TRUE,
                    Distance := (GVL_Recipe.stSolventNTimes.aVelocity[1] * TIME_TO_REAL(GVL_Recipe.stOtherParams.tAgitate1Time)) / 1.8,
                    Velocity := GVL_Recipe.stSolventNTimes.aVelocity[1],
                    Axis := GVL_Motion.aPumps[i].Rotary.Axis);

                IF fbPumpRotary[i].Error THEN
                    // Tratamento de erro opcional
                    bAllPumpsDone := FALSE;
                    iStepCounter := 999; // Estado de erro (opcional)
                ELSIF NOT fbPumpRotary[i].Done THEN
                    bAllPumpsDone := FALSE;
                END_IF
            END_FOR

            IF bAllPumpsDone THEN
                // Reset dos FBs
                FOR i := 1 TO 10 DO
                    fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
                END_FOR

                bMovementStarted := FALSE;
                bMovementComplete := TRUE;
                iStepCounter := 0; // reset para próximo uso
            END_IF
        END_IF
*)
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Method Name="Reset" Id="{12eefff6-07c0-42e5-ab61-91712c03c502}">
      <Declaration><![CDATA[METHOD Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Action Name="ResetAll" Id="{b37c62b3-f3cd-48cf-8953-7840e35e64e5}">
      <Implementation>
        <ST><![CDATA[
// Reset solenoid control
fbSolenoidControl(bExecute := FALSE, eSolenoidSet := E_SolenoidSet.IDLE);

// Reset Timers
timerSoak(IN := FALSE, PT := T#0S);
timerAgitate(IN := FALSE, PT := T#0S);

// Reset Flags
bMovementComplete 	:= FALSE;
bInitComplete 		:= FALSE;
bDone 				:= FALSE;
eRecoveryState 		:= E_RecoveryState.Idle;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="SolventSoak" Id="{024c621c-c960-47f6-8737-9a73b1607501}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF

    0: // Initialize the Soak timer
        timerSoak(IN := TRUE, PT := GVL_Recipe.stOtherParams.tSoakTime);
        bTimerStarted := TRUE;

        iStepCounter := 1;

    1: // Wait for the timer to complete the time
        timerSoak(IN := bTimerStarted, PT := GVL_Recipe.stOtherParams.tSoakTime);

        IF timerSoak.Q THEN
            // Time completed, reset the timer
            timerSoak(IN := FALSE);
            bTimerStarted := FALSE;

            // Marks the end of the action
            bMovementComplete := TRUE;
            iStepCounter := 0; // reset for next use
        END_IF

END_CASE
]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_RecoveryPhase">
      <LineId Id="541" Count="113" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1">
      <LineId Id="2" Count="46" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1and2">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.DisposeRemainingSolvent">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.FillAdditionalVials">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.GetPumpVolume">
      <LineId Id="10" Count="14" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent1">
      <LineId Id="2" Count="4" />
      <LineId Id="178" Count="0" />
      <LineId Id="184" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="15" Count="46" />
      <LineId Id="91" Count="6" />
      <LineId Id="68" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="79" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="124" Count="31" />
      <LineId Id="162" Count="15" />
      <LineId Id="161" Count="0" />
      <LineId Id="88" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent2">
      <LineId Id="84" Count="0" />
      <LineId Id="2" Count="81" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MixSolvent1and2">
      <LineId Id="87" Count="0" />
      <LineId Id="2" Count="7" />
      <LineId Id="86" Count="0" />
      <LineId Id="11" Count="74" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MoveToPosition">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MoveToWastePosition">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.PrimeNeedles">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.RecirculateSolvent1">
      <LineId Id="152" Count="74" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Reset">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.ResetAll">
      <LineId Id="33" Count="0" />
      <LineId Id="7" Count="2" />
      <LineId Id="25" Count="7" />
      <LineId Id="1" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.SolventSoak">
      <LineId Id="2" Count="21" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>