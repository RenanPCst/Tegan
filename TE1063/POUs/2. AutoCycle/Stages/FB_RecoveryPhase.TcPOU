<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_RecoveryPhase" Id="{83f5ec5b-6c67-443f-8065-7a3e8ba1c7ee}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RecoveryPhase

VAR_INPUT
    bExecute : BOOL; 
END_VAR

VAR_OUTPUT
	bSuccess 		: BOOL;	//Success Flag
    bError 			: BOOL; //Error Flag
    
END_VAR

VAR
	eRecoveryState : E_RecoveryState := E_RecoveryState.Idle;
    bInitComplete : BOOL := FALSE;

    fbSolenoidControl : FB_SolenoidControl;
	
	//Error Handle
	bErrorDetected   : BOOL := FALSE;
    nPumpWithError   : INT := 0;
    nErrorID         : UDINT := 0;

    iStepCounter : INT := 0;
    i : USINT; //loop for index
	
	//Timers
	timerAgitate : TON;
	// Control flags
	bStart		: BOOL := FALSE;
	bDone		: BOOL := FALSE;
	bReset		: BOOL := FALSE;
    bMoveM2 	: BOOL := FALSE;
	bMoveM3		: BOOL := FALSE;
    bMovementComplete : BOOL := FALSE;
	
	
	//Metering Rinse 1
	bMoveValveDone		 : ARRAY[1..5] OF BOOL;
	bMovePumpDone		 : ARRAY[1..10] OF BOOL;
	fDistance        	 : ARRAY[1..10] OF REAL;
    bAllValvesInPosition : BOOL := TRUE;
    bAllPumpsDone        : BOOL := TRUE;
	bMoveValvesDone		 : ARRAY[1..5] OF BOOL;
	
	//Recirculate Solvent 1
	bAllValvesInPos  : BOOL := FALSE;
    bMovementStarted : BOOL := FALSE;
    fAgitationTime   : REAL := 0;
	fCalcDistance	 : ARRAY[1..10] OF REAL;
	
	//Solvent Soak
	timerSoak       : TON;
    bTimerStarted   : BOOL := FALSE;
	bSoakTimerDone  : BOOL := FALSE;
	
	//Metering Rinse 2
	
	
	//Debug Variables
	bDebug : ARRAY[1..20] OF BOOL;
	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bStart THEN
	eRecoveryState := E_RecoveryState.Idle;
	bStart := bExecute;
END_IF

CASE eRecoveryState OF

    E_RecoveryState.Idle:
		bDone := FALSE;
		//Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Starting'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 0;
		
		
		IF bReset THEN
			ResetAll(); // Reset All Action.
		END_IF
		
        IF bStart THEN
            eRecoveryState := E_RecoveryState.Metering_Solvent1;
            bInitComplete  := FALSE;
        END_IF;

    E_RecoveryState.Metering_Solvent1:
	IF bDebug[1] THEN
        MeteringSolvent1(); //OK
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Recirculate_Solvent1;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	END_IF

    E_RecoveryState.Recirculate_Solvent1:
	IF bDebug[2] THEN
        RecirculateSolvent1(); //OK
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Solvent_Soak;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	END_IF
	
    E_RecoveryState.Solvent_Soak:
	IF bDebug[3] THEN
        SolventSoak(); //onReview
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	END_IF

    E_RecoveryState.Cleaning_Lines_S1: //*
	IF bDebug[4] THEN
        CleaningLinesSolvent1(); //onReview
        IF bMovementComplete THEN
            IF GVL_Recipe.stSolventNTimes.aSolventN[2] <> 0 THEN
                eRecoveryState := E_RecoveryState.Metering_Solvent2;
				iStepCounter := 0;
            	bMovementComplete := FALSE;
            ELSE
                eRecoveryState := E_RecoveryState.Cleaning_Lines_S1_S2; // Skip to next applicable state
				iStepCounter := 0;
            	bMovementComplete := FALSE;
            END_IF
            bMovementComplete := FALSE;
        END_IF
	END_IF

    E_RecoveryState.Metering_Solvent2:
	IF bDebug[5] THEN
        MeteringSolvent2(); //onReview
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Mix_Solvent1_2;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	END_IF

    E_RecoveryState.Mix_Solvent1_2:
	IF bDebug[6] THEN
        MixSolvent1and2(); //onReview
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1_S2;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	END_IF
	
    E_RecoveryState.Cleaning_Lines_S1_S2:
	IF bDebug[7] THEN
        CleaningLinesSolvent1and2(); //onReview
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Prime_Needles;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	END_IF

    E_RecoveryState.Prime_Needles:
	IF bDebug[8] THEN
        PrimeNeedles(); 
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Fill_Vials_Row_1;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF
	END_IF

    E_RecoveryState.Fill_Vials_Row_1:
	IF bDebug[9] THEN
        Fill_Vials_Row_1();
        IF bMovementComplete THEN
            IF GVL_Recipe.stOtherParams.iVialsToFill > 1 THEN
                eRecoveryState := E_RecoveryState.Fill_Vials_Row_2;
            ELSE
                eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            END_IF
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	END_IF
		
    E_RecoveryState.Fill_Vials_Row_2:
	IF bDebug[10] THEN
        Fill_Vials_Row_2();
        IF bMovementComplete THEN
            IF GVL_Recipe.stOtherParams.iVialsToFill > 2 THEN
                eRecoveryState := E_RecoveryState.Fill_Vials_Row_3;
            ELSE
                eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            END_IF
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	END_IF
	
	E_RecoveryState.Fill_Vials_Row_3:
	IF bDebug[11] THEN
        Fill_Vials_Row_3();
        IF bMovementComplete THEN
            IF GVL_Recipe.stOtherParams.iVialsToFill > 3 THEN
                eRecoveryState := E_RecoveryState.Fill_Vials_Row_4;
            ELSE
                eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            END_IF
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	END_IF
	
	E_RecoveryState.Fill_Vials_Row_4:
	IF bDebug[12] THEN
        Fill_Vials_Row_4();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Waste_Remaining_Solvent;
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	END_IF

    E_RecoveryState.Waste_Remaining_Solvent:
	IF bDebug[13] THEN
        WasteRemainingSolvent();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Completed;
            bMovementComplete := FALSE;
			iStepCounter := 0;
        END_IF
	END_IF

    E_RecoveryState.Completed:
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Completed'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 100;
		bDone := TRUE;

END_CASE;
]]></ST>
    </Implementation>
    <Action Name="CleaningLinesSolvent1" Id="{9273111f-dd95-4702-809f-ba9c490b1159}">
      <Implementation>
        <ST><![CDATA[//Exactly the oppisite of Recirculate Solvent 1
CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Cleaning Solvent Lines'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 30;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 1

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] := fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [positive moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="CleaningLinesSolvent1and2" Id="{87b6bc97-2d34-4577-b9ae-634c57593673}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Cleaning the lines'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 60;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 2

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] 	:= fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="Fill_Vials_Row_1" Id="{175ea493-1eff-4a16-bd97-613f6d5c4b1b}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Fill Vials R1'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 65;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 6 - Needles
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF
		
	2: // Movimento dos motores M2 e M3
		IF NOT bMoveM2 THEN
			bMoveM2 := GVL_Motion.aMotors[2].MoveAbsolute(	rPosition := GVL_Settings.stMachineParam.aM1Position[2], 
															rVelocity := GVL_Settings.stMachineParam.rM1Velocity,
															rAcc := GVL_Settings.stMachineParam.rM1Accleration, 
															rDec := GVL_Settings.stMachineParam.rM1Deceleration	
														 	);
		END_IF
 

    3: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 2

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] 	:= fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    4: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    5: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="Fill_Vials_Row_2" Id="{4d0f44b2-18a7-4986-9bc7-67bfa926fd0f}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="Fill_Vials_Row_3" Id="{64765b9d-3a6b-4f52-8a3a-ae25b14c22a3}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="Fill_Vials_Row_4" Id="{491460a0-4929-4ea4-bfa4-c7a25ac97b70}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Method Name="GetPumpVolume" Id="{92e83561-92ab-423b-96a0-648f72e2e29e}">
      <Declaration><![CDATA[METHOD PRIVATE GetPumpVolume : REAL
VAR_INPUT
	iPump : INT;  // Pump number 1..10
    iStep : INT;  // 1..4 [step Rinse 1 | Rinse 2 | Wash 1 | Wash 2] 
END_VAR
VAR
    volume : REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE iPump OF
    1: volume := GVL_Recipe.stVolumes.aT_IC_Volume[iStep];
    2: volume := GVL_Recipe.stVolumes.aS0_Volume[iStep];
    3: volume := GVL_Recipe.stVolumes.aS1_Volume[iStep];
    4: volume := GVL_Recipe.stVolumes.aS2_Volume[iStep];
    5: volume := GVL_Recipe.stVolumes.aS3_Volume[iStep];
    6: volume := GVL_Recipe.stVolumes.aS4_Volume[iStep];
    7: volume := GVL_Recipe.stVolumes.aS5_Volume[iStep];
    8: volume := GVL_Recipe.stVolumes.aS6_Volume[iStep];
    9: volume := GVL_Recipe.stVolumes.aS7_Volume[iStep];
    10: volume := GVL_Recipe.stVolumes.aF_Volume[iStep];
    ELSE
        volume := 0.0;
END_CASE

GetPumpVolume := volume;]]></ST>
      </Implementation>
    </Method>
    <Action Name="MeteringSolvent1" Id="{043bbe9a-a49a-4e9b-8157-9bfa39662a89}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Metering Rinse 1'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 10;
		iStepCounter := 1;
	
    1: // Initialization: Reset solenoids and set valves
        fbSolenoidControl(bExecute := TRUE, eSolenoidSet := E_SolenoidSet.IDLE);
		
		IF fbSolenoidControl.bDone THEN
			iStepCounter := 2;
		END_IF
		
    2: // Set valves for Rinse 1 position
	    FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
				bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := GVL_Recipe.stActiveRecipe.stSolventsTimes.aSolventN[1], 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
			
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 3;
		END_IF
        
	3: //Calculating the distance for each pump
		fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[1], iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[1], iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[1], iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[1], iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[1], iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[1], iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[1], iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[1], iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[1], iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[1], iPumpIndex := 10);
		
		iStepCounter := 4;
		
    4: // Performs rotary movement (positive movement)
        FOR i := 1 TO 10 DO
            IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step to monitor completion
		END_IF
	
	5: // Sets the movement done flag
		bMovementComplete := TRUE;
         
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="MeteringSolvent2" Id="{ab3c9a64-fa5a-49bd-80d9-c7e2f0aaf572}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Metering Rinse 2'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 40;
		iStepCounter := 1;
	
    1: // Initialization: Reset solenoids and set valves
        fbSolenoidControl(bExecute := TRUE, eSolenoidSet := E_SolenoidSet.IDLE);
		
		IF fbSolenoidControl.bDone THEN
			iStepCounter := 2;
		END_IF
		
    2: // Set valves for Rinse 2 position
	    FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
				bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := GVL_Recipe.stActiveRecipe.stSolventsTimes.aSolventN[2], 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
			
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 3;
		END_IF
        
	3: //Calculating the distance for each pump
		fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[2], iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[2], iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[2], iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[2], iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[2], iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[2], iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[2], iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[2], iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[2], iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[2], iPumpIndex := 10);
		
		iStepCounter := 4;
		
    4: // Performs rotary movement (positive movement)
        FOR i := 1 TO 10 DO
            IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step to monitor completion
		END_IF
	
	5: // Sets the movement done flag
		bMovementComplete := TRUE;
         
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="MixSolvent1and2" Id="{be5d325a-d90b-476e-8b7a-b5a6c59989fc}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Mix Solvents 1 and 2'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 50;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 2

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] 	:= fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="PrimeNeedles" Id="{40407892-18b3-49ae-adf9-38d07aae6967}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Prime Needles'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 65;
		iStepCounter := 1;
	
    1: // Set valves for Needles position
	    FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
				bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 6, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
			
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF
        
	2: //Calculating the distance for each pump
		fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stOtherParams.rVialPrimeVol, iPumpIndex := 10);
		
		iStepCounter := 3;
		
    3: // Performs rotary movement (positive movement)
        FOR i := 1 TO 10 DO
            IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF
	
	4: // Sets the movement done flag
		bMovementComplete := TRUE;
         
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="RecirculateSolvent1" Id="{dd88b683-a3d6-421a-a9d9-04dab5a1112d}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Recirculate Solvent 1'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 20;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 1

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		FOR i := 1 TO 10 DO
			fCalcDistance[i] 	:= fAgitationTime * GVL_Motion.aPumps[i].Rotary.rSpeed;
		END_FOR
		
		IF fAgitationTime > 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fCalcDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Method Name="Reset" Id="{12eefff6-07c0-42e5-ab61-91712c03c502}">
      <Declaration><![CDATA[METHOD Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Init Flags
bInitComplete 	:= FALSE;
bErrorDetected  := FALSE;
nPumpWithError  := 0;
nErrorID   		:= 0;
iStepCounter 	:= 0;

// Control flags
bStart	  		:= FALSE;
bDone	  		:= FALSE;
bReset	  		:= FALSE;
bMovementComplete := FALSE;

//Metering Rinse 1
bAllValvesInPosition  := TRUE;
bAllPumpsDone         := TRUE;

//Recirculate Solvent 1
bAllValvesInPos   	:= FALSE;
bMovementStarted 	:= FALSE;
fAgitationTime    	:= 0;

FOR i := 1 TO 10 DO
	fCalcDistance[i] := 0;
END_FOR

//Solvent Soak
bTimerStarted   := FALSE;
bSoakTimerDone  := FALSE;

IF NOT bInitComplete AND bErrorDetected THEN
	Reset := TRUE;
	RETURN;
ELSE
	Reset := FALSE;
END_IF

	

	]]></ST>
      </Implementation>
    </Method>
    <Action Name="ResetAll" Id="{b37c62b3-f3cd-48cf-8953-7840e35e64e5}">
      <Implementation>
        <ST><![CDATA[
// Reset solenoid control
fbSolenoidControl(bExecute := FALSE, eSolenoidSet := E_SolenoidSet.IDLE);

// Reset Timers
timerSoak(IN := FALSE, PT := T#0S);
timerAgitate(IN := FALSE, PT := T#0S);

// Reset Flags
bMovementComplete 	:= FALSE;
bInitComplete 		:= FALSE;
bDone 				:= FALSE;
eRecoveryState 		:= E_RecoveryState.Idle;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="SolventSoak" Id="{024c621c-c960-47f6-8737-9a73b1607501}">
      <Implementation>
        <ST><![CDATA[//Provide HMI animation details
GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Solvent Soak'; 
GVL_HMI.HMIAnimation.rLoadBarRecovery  := 30;

// Initialize the Soak timer
bTimerStarted := TRUE;

IF timerSoak.Q THEN
	// Time completed, reset the timer
	bTimerStarted := FALSE;
	bSoakTimerDone := TRUE;
END_IF

// Wait for the timer to complete the time
timerSoak(IN := bTimerStarted, PT := GVL_Recipe.stActiveRecipe.stOtherParams.tSoakTime);

IF bSoakTimerDone THEN
	// Marks the end of the action
	bMovementComplete := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Action>
    <Action Name="WasteRemainingSolvent" Id="{a506e020-7a9f-47c0-ade1-266bb776f9c2}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_RecoveryPhase">
      <LineId Id="851" Count="123" />
      <LineId Id="1008" Count="11" />
      <LineId Id="981" Count="0" />
      <LineId Id="1020" Count="0" />
      <LineId Id="1022" Count="11" />
      <LineId Id="1021" Count="0" />
      <LineId Id="1034" Count="0" />
      <LineId Id="1036" Count="3" />
      <LineId Id="1043" Count="0" />
      <LineId Id="1045" Count="2" />
      <LineId Id="1035" Count="0" />
      <LineId Id="982" Count="0" />
      <LineId Id="991" Count="0" />
      <LineId Id="1048" Count="0" />
      <LineId Id="992" Count="5" />
      <LineId Id="1049" Count="0" />
      <LineId Id="998" Count="1" />
      <LineId Id="1051" Count="2" />
      <LineId Id="1006" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1">
      <LineId Id="207" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="153" Count="25" />
      <LineId Id="208" Count="2" />
      <LineId Id="179" Count="26" />
      <LineId Id="150" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1and2">
      <LineId Id="2" Count="56" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_1">
      <LineId Id="2" Count="23" />
      <LineId Id="59" Count="2" />
      <LineId Id="63" Count="0" />
      <LineId Id="65" Count="3" />
      <LineId Id="64" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="26" Count="32" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_2">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_3">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Fill_Vials_Row_4">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.GetPumpVolume">
      <LineId Id="10" Count="14" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent1">
      <LineId Id="216" Count="0" />
      <LineId Id="3" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="219" Count="2" />
      <LineId Id="218" Count="0" />
      <LineId Id="4" Count="2" />
      <LineId Id="204" Count="2" />
      <LineId Id="208" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="244" Count="3" />
      <LineId Id="242" Count="1" />
      <LineId Id="212" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="189" Count="1" />
      <LineId Id="188" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="222" Count="1" />
      <LineId Id="225" Count="5" />
      <LineId Id="232" Count="2" />
      <LineId Id="236" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="237" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="239" Count="0" />
      <LineId Id="192" Count="2" />
      <LineId Id="213" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="196" Count="4" />
      <LineId Id="195" Count="0" />
      <LineId Id="201" Count="2" />
      <LineId Id="72" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent2">
      <LineId Id="85" Count="67" />
      <LineId Id="84" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MixSolvent1and2">
      <LineId Id="88" Count="26" />
      <LineId Id="143" Count="6" />
      <LineId Id="120" Count="22" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.PrimeNeedles">
      <LineId Id="2" Count="6" />
      <LineId Id="16" Count="53" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.RecirculateSolvent1">
      <LineId Id="152" Count="1" />
      <LineId Id="275" Count="1" />
      <LineId Id="274" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="277" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="239" Count="4" />
      <LineId Id="282" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="283" Count="0" />
      <LineId Id="246" Count="4" />
      <LineId Id="161" Count="2" />
      <LineId Id="251" Count="1" />
      <LineId Id="285" Count="2" />
      <LineId Id="255" Count="0" />
      <LineId Id="257" Count="2" />
      <LineId Id="253" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="261" Count="4" />
      <LineId Id="280" Count="0" />
      <LineId Id="266" Count="5" />
      <LineId Id="192" Count="2" />
      <LineId Id="272" Count="1" />
      <LineId Id="225" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Reset">
      <LineId Id="56" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="19" Count="0" />
      <LineId Id="23" Count="4" />
      <LineId Id="29" Count="2" />
      <LineId Id="35" Count="1" />
      <LineId Id="38" Count="4" />
      <LineId Id="69" Count="0" />
      <LineId Id="66" Count="2" />
      <LineId Id="55" Count="0" />
      <LineId Id="46" Count="2" />
      <LineId Id="60" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="63" Count="2" />
      <LineId Id="62" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.ResetAll">
      <LineId Id="33" Count="0" />
      <LineId Id="7" Count="2" />
      <LineId Id="25" Count="7" />
      <LineId Id="1" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.SolventSoak">
      <LineId Id="33" Count="3" />
      <LineId Id="4" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="12" Count="2" />
      <LineId Id="16" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.WasteRemainingSolvent">
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>