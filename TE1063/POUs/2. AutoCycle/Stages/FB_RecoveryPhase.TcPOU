<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_RecoveryPhase" Id="{83f5ec5b-6c67-443f-8065-7a3e8ba1c7ee}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RecoveryPhase

VAR_INPUT
    bExecute : BOOL; 
END_VAR

VAR_OUTPUT
	bSuccess 		: BOOL;	//Success Flag
    bError 			: BOOL; //Error Flag
    
END_VAR

VAR
	eRecoveryState : E_RecoveryState := E_RecoveryState.Idle;
    bInitComplete : BOOL := FALSE;

    fbSolenoidControl : FB_SolenoidControl;
	
	//Error Handle
	bErrorDetected   : BOOL := FALSE;
    nPumpWithError   : INT := 0;
    nErrorID         : UDINT := 0;

    iStepCounter : INT := 0;
    i : USINT; //loop for index
	
	//Timers
	timerAgitate : TON;
	// Control flags
	bStart		: BOOL := FALSE;
	bDone		: BOOL := FALSE;
	bReset		: BOOL := FALSE;
    bMoveServo 	: BOOL := TRUE;
    bMovementComplete : BOOL := FALSE;
	
	//Metering Rinse 1
	bMoveValveDone		 : ARRAY[1..5] OF BOOL;
	bMovePumpDone		 : ARRAY[1..10] OF BOOL;
	fDistance        	 : ARRAY[1..10] OF REAL;
    bAllValvesInPosition : BOOL := TRUE;
    bAllPumpsDone        : BOOL := TRUE;
	bMoveValvesDone		 : ARRAY[1..5] OF BOOL;
	
	//Recirculate Solvent 1
	bAllValvesInPos  : BOOL := FALSE;
    bMovementStarted : BOOL := FALSE;
    fAgitationTime   : REAL := 0;
	fCalcDistance	 : REAL := 0;
	
	//Solvent Soak
	timerSoak       : TON;
    bTimerStarted   : BOOL := FALSE;
	bSoakTimerDone  : BOOL := FALSE;
	
	//Metering Rinse 2
	
	
	//Debug Variables
	bDebug : ARRAY[1..20] OF BOOL;
	

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bStart THEN
	eRecoveryState := E_RecoveryState.Idle;
	bStart := bExecute;
END_IF

CASE eRecoveryState OF

    E_RecoveryState.Idle:
		bDone := FALSE;
		//Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Starting'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 0;
		
		
		IF bReset THEN
			ResetAll(); // Reset All Action.
		END_IF
		
        IF bStart THEN
            eRecoveryState := E_RecoveryState.Metering_Solvent1;
            bInitComplete  := FALSE;
        END_IF;

    E_RecoveryState.Metering_Solvent1:
	IF bDebug[1] THEN
        MeteringSolvent1(); //Action
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Recirculate_Solvent1;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF;
	END_IF

    E_RecoveryState.Recirculate_Solvent1:
	IF bDebug[2] THEN
        RecirculateSolvent1();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Solvent_Soak;
			iStepCounter := 0;
            bMovementComplete := FALSE;
        END_IF;
	END_IF
	
    E_RecoveryState.Solvent_Soak:
	IF bDebug[3] THEN
        SolventSoak();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1;
            bMovementComplete := FALSE;
        END_IF;
	END_IF

    E_RecoveryState.Cleaning_Lines_S1: //*
        CleaningLinesSolvent1();
        IF bMovementComplete THEN
            IF GVL_Recipe.stSolventNTimes.aSolventN[2] <> 0 THEN
                eRecoveryState := E_RecoveryState.Metering_Solvent2;
            ELSE
                eRecoveryState := E_RecoveryState.Cleaning_Lines_S1_S2; // Skip to next applicable state
            END_IF;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Metering_Solvent2:
        MeteringSolvent2();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Mix_Solvent1_2;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Mix_Solvent1_2:
        MixSolvent1and2();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Cleaning_Lines_S1_S2;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Cleaning_Lines_S1_S2:
        CleaningLinesSolvent1and2();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Prime_Needles;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Prime_Needles:
        PrimeNeedles();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Move_to_Position1;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Move_to_Position1:
        MoveToPosition();
        IF bMovementComplete THEN
            IF GVL_Recipe.stOtherParams.iVialsToFill > 1 THEN
                eRecoveryState := E_RecoveryState.Fill_Vials;
            ELSE
                eRecoveryState := E_RecoveryState.Move_To_Waste;
            END_IF;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Fill_Vials:
        FillAdditionalVials();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Move_To_Waste;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Move_To_Waste:
        MoveToWastePosition();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Dispose_Remaining_Solvent;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Dispose_Remaining_Solvent:
        DisposeRemainingSolvent();
        IF bMovementComplete THEN
            eRecoveryState := E_RecoveryState.Completed;
            bMovementComplete := FALSE;
        END_IF;

    E_RecoveryState.Completed:
        bDone := TRUE;
        IF bReset THEN
            eRecoveryState := E_RecoveryState.Idle;
            bDone := FALSE;
        END_IF;

END_CASE;
]]></ST>
    </Implementation>
    <Action Name="CleaningLinesSolvent1" Id="{9273111f-dd95-4702-809f-ba9c490b1159}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
(*
    0: // Inicia movimento reverse (negativo) para retornar solvente para as jarras
        FOR i := 1 TO 10 DO
            fbPumpRotary[i](
                Execute := TRUE,
                Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 1), iPumpIndex := i), // negativo = reverse
                Velocity := GVL_Recipe .stSolventNTimes.aVelocity[1],
                Axis := GVL_Motion.aPumps[i].Rotary.Axis);
        END_FOR

        bMovementStarted := TRUE;
        iStepCounter := 1;

    1: // Aguarda término do movimento das bombas
        IF bMovementStarted THEN
            bAllPumpsDone := TRUE;

            FOR i := 1 TO 10 DO
                fbPumpRotary[i](
                    Execute := TRUE,
                    Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 1), iPumpIndex := i),
                    Velocity := GVL_Recipe.stSolventNTimes.aVelocity[1],
                    Axis := GVL_Motion.aPumps[i].Rotary.Axis);

                IF fbPumpRotary[i].Error THEN
                    // Opcional: tratamento de erro aqui
                    bAllPumpsDone := FALSE;
                    iStepCounter := 999; // Estado de erro opcional
                ELSIF NOT fbPumpRotary[i].Done THEN
                    bAllPumpsDone := FALSE;
                END_IF
            END_FOR

            IF bAllPumpsDone THEN
                // Reset dos FBs após concluir movimento
                FOR i := 1 TO 10 DO
                    fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
                END_FOR

                bMovementStarted := FALSE;
                bMovementComplete := TRUE;
                iStepCounter := 0; // reset para próximo uso
            END_IF
        END_IF
*)
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="CleaningLinesSolvent1and2" Id="{87b6bc97-2d34-4577-b9ae-634c57593673}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="DisposeRemainingSolvent" Id="{a506e020-7a9f-47c0-ade1-266bb776f9c2}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="FillAdditionalVials" Id="{d24df81f-3d3e-477c-843f-8d6a95d22a6d}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Method Name="GetPumpVolume" Id="{92e83561-92ab-423b-96a0-648f72e2e29e}">
      <Declaration><![CDATA[METHOD PRIVATE GetPumpVolume : REAL
VAR_INPUT
	iPump : INT;  // Pump number 1..10
    iStep : INT;  // 1..4 [step Rinse 1 | Rinse 2 | Wash 1 | Wash 2] 
END_VAR
VAR
    volume : REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE iPump OF
    1: volume := GVL_Recipe.stVolumes.aT_IC_Volume[iStep];
    2: volume := GVL_Recipe.stVolumes.aS0_Volume[iStep];
    3: volume := GVL_Recipe.stVolumes.aS1_Volume[iStep];
    4: volume := GVL_Recipe.stVolumes.aS2_Volume[iStep];
    5: volume := GVL_Recipe.stVolumes.aS3_Volume[iStep];
    6: volume := GVL_Recipe.stVolumes.aS4_Volume[iStep];
    7: volume := GVL_Recipe.stVolumes.aS5_Volume[iStep];
    8: volume := GVL_Recipe.stVolumes.aS6_Volume[iStep];
    9: volume := GVL_Recipe.stVolumes.aS7_Volume[iStep];
    10: volume := GVL_Recipe.stVolumes.aF_Volume[iStep];
    ELSE
        volume := 0.0;
END_CASE

GetPumpVolume := volume;]]></ST>
      </Implementation>
    </Method>
    <Action Name="MeteringSolvent1" Id="{043bbe9a-a49a-4e9b-8157-9bfa39662a89}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Metering Rinse 1'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 10;
		iStepCounter := 1;
	
    1: // Initialization: Reset solenoids and set valves
        fbSolenoidControl(bExecute := TRUE, eSolenoidSet := E_SolenoidSet.IDLE);
		
		IF fbSolenoidControl.bDone THEN
			iStepCounter := 2;
		END_IF
		
    2: // Set valves for Rinse 1 position
	    FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
				bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := GVL_Recipe.stActiveRecipe.stSolventsTimes.aSolventN[1], 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
			
        END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 3;
		END_IF
        
	3: //Calculating the distance for each pump
		fDistance[1] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aT_IC_Volume[1], iPumpIndex := 1);
		fDistance[2] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS0_Volume[1], iPumpIndex := 2);
		fDistance[3] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS1_Volume[1], iPumpIndex := 3);
		fDistance[4] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS2_Volume[1], iPumpIndex := 4);
		fDistance[5] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS3_Volume[1], iPumpIndex := 5);
		fDistance[6] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS4_Volume[1], iPumpIndex := 6);
		fDistance[7] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS5_Volume[1], iPumpIndex := 7);
		fDistance[8] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS6_Volume[1], iPumpIndex := 8);
		fDistance[9] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aS7_Volume[1], iPumpIndex := 9);
		fDistance[10] := F_VolumeToSteps(rVolume := GVL_Recipe.stActiveRecipe.stVolumes.aF_Volume[1], iPumpIndex := 10);
		
		iStepCounter := 4;
		
    4: // Performs rotary movement (positive movement)
        FOR i := 1 TO 10 DO
            IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := fDistance[i],
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 5; // Move to next step to monitor completion
		END_IF
	
	5: // Sets the movement done flag
		bMovementComplete := TRUE;
         
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="MeteringSolvent2" Id="{ab3c9a64-fa5a-49bd-80d9-c7e2f0aaf572}">
      <Implementation>
        <ST><![CDATA[(*
IF GVL_Recipe.stSolventNTimes.aSolventN[2] = 0 THEN
    // Solvent 2 não definido, pula etapa diretamente
    bMovementComplete := TRUE;
    iStepCounter := 0;
ELSE

    CASE iStepCounter OF

        0: // Posicionar válvulas no solvente número 2
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := GVL_Recipe.stSolventNTimes.aSolventN[2]);
            END_FOR

            iStepCounter := 1;

        1: // Aguarda posicionamento das válvulas
            bAllValvesInPos := TRUE;
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := GVL_Recipe.stSolventNTimes.aSolventN[2]);

                IF NOT aValveController[i].bMoveDone THEN
                    bAllValvesInPos := FALSE;
                END_IF
            END_FOR

            IF bAllValvesInPos THEN
                iStepCounter := 2;
            END_IF

        2: // Movimentar atuador rotativo das bombas (sentido negativo/reverse)
            FOR i := 1 TO 10 DO
                fbPumpRotary[i](
                    Execute := TRUE,
                    Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 2), iPumpIndex := i), // negativo
                    Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                    Axis := GVL_Motion.aPumps[i].Rotary.Axis);
            END_FOR

            bMovementStarted := TRUE;
            iStepCounter := 3;

        3: // Aguarda término do movimento das bombas
            IF bMovementStarted THEN
                bAllPumpsDone := TRUE;

                FOR i := 1 TO 10 DO
                    fbPumpRotary[i](
                        Execute := TRUE,
                        Distance := -F_VolumeToSteps(fVolume := GetPumpVolume(i, 2), iPumpIndex := i),
                        Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                        Axis := GVL_Motion.aPumps[i].Rotary.Axis);

                    IF fbPumpRotary[i].Error THEN
                        // Opcional: tratamento de erro
                        bAllPumpsDone := FALSE;
                        iStepCounter := 999; // estado de erro opcional
                    ELSIF NOT fbPumpRotary[i].Done THEN
                        bAllPumpsDone := FALSE;
                    END_IF
                END_FOR

                IF bAllPumpsDone THEN
                    // Reset dos FBs
                    FOR i := 1 TO 10 DO
                        fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
                    END_FOR

                    bMovementStarted := FALSE;
                    bMovementComplete := TRUE;
                    iStepCounter := 0; // reset para próximo uso
                END_IF
            END_IF

    END_CASE

END_IF
*)]]></ST>
      </Implementation>
    </Action>
    <Action Name="MixSolvent1and2" Id="{be5d325a-d90b-476e-8b7a-b5a6c59989fc}">
      <Implementation>
        <ST><![CDATA[(*
IF GVL_Recipe.stSolventNTimes.aSolventN[2] = 0 THEN
    // Solvent 2 não definido, pula essa etapa diretamente
    bMovementComplete := TRUE;
    iStepCounter := 0;
ELSE

    CASE iStepCounter OF

        0: // Posicionar válvulas na posição 5 (recirculação)
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := 5);
            END_FOR

            iStepCounter := 1;

        1: // Aguarda posicionamento das válvulas
            bAllValvesInPos := TRUE;
            FOR i := 1 TO 5 DO
                aValveController[i](
                    bEnable := TRUE,
                    ServoAxis := GVL_Motion.aValves[i].Axis,
                    iValvePosition := 5);

                IF NOT aValveController[i].bMoveDone THEN
                    bAllValvesInPos := FALSE;
                END_IF
            END_FOR

            IF bAllValvesInPos THEN
                iStepCounter := 2;
            END_IF

        2: // Inicia movimento forward das bombas para misturar solventes
            FOR i := 1 TO 10 DO
                fCalcDistance := (GVL_Recipe.stSolventNTimes.aVelocity[2] * TIME_TO_REAL(GVL_Recipe.stOtherParams.tAgitate2Time)) / 1.8;

                fbPumpRotary[i](
                    Execute := TRUE,
                    Distance := fCalcDistance, // positivo = forward
                    Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                    Axis := GVL_Motion.aPumps[i].Rotary.Axis);
            END_FOR

            bMovementStarted := TRUE;
            iStepCounter := 3;

        3: // Aguarda término do movimento de mistura das bombas
            IF bMovementStarted THEN
                bAllPumpsDone := TRUE;

                FOR i := 1 TO 10 DO
                    fbPumpRotary[i](
                        Execute := TRUE,
                        Distance := (GVL_Recipe.stSolventNTimes.aVelocity[2] * TIME_TO_REAL(GVL_Recipe.stOtherParams.tAgitate2Time)) / 1.8,
                        Velocity := GVL_Recipe.stSolventNTimes.aVelocity[2],
                        Axis := GVL_Motion.aPumps[i].Rotary.Axis);

                    IF fbPumpRotary[i].Error THEN
                        // Opcional: tratamento de erro
                        bAllPumpsDone := FALSE;
                        iStepCounter := 999; // estado de erro opcional
                    ELSIF NOT fbPumpRotary[i].Done THEN
                        bAllPumpsDone := FALSE;
                    END_IF
                END_FOR

                IF bAllPumpsDone THEN
                    // Reset dos FBs
                    FOR i := 1 TO 10 DO
                        fbPumpRotary[i](Execute := FALSE, Distance := 0, Velocity := 0, Axis := GVL_Motion.aPumps[i].Rotary.Axis);
                    END_FOR

                    bMovementStarted := FALSE;
                    bMovementComplete := TRUE;
                    iStepCounter := 0; // reset para próximo uso
                END_IF
            END_IF

    END_CASE

END_IF
*)]]></ST>
      </Implementation>
    </Action>
    <Action Name="MoveToPosition" Id="{e91bc937-13f8-4d14-a3d2-4237e5f04640}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="MoveToWastePosition" Id="{0d088b26-2d05-4186-b5b4-abd253dadf13}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="PrimeNeedles" Id="{40407892-18b3-49ae-adf9-38d07aae6967}">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Action Name="RecirculateSolvent1" Id="{dd88b683-a3d6-421a-a9d9-04dab5a1112d}">
      <Implementation>
        <ST><![CDATA[CASE iStepCounter OF
	
	0: //Provide HMI animation details
		GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Recirculate Solvent 1'; 
		GVL_HMI.HMIAnimation.rLoadBarRecovery  := 20;
		iStepCounter := 1;
		
    1: // Setar válvulas para posição 5 (Recirculação)
    	FOR i := 1 TO 5 DO
			IF NOT bMoveValveDone[i] THEN
			bMoveValveDone[i] := GVL_Motion.aValvesObj[i].MoveValve( iPosition := 5, 
																	 rVelocity := GVL_Motion.aValves[i].rTargetVel, 
																	 rAcc := GVL_Motion.aValves[i].rAcceleration, 
																	 rDec := GVL_Motion.aValves[i].rDeceleration 
																	);
			END_IF
		END_FOR
		
		IF bMoveValveDone[1] AND bMoveValveDone[2] AND bMoveValveDone[3] AND bMoveValveDone[4] AND bMoveValveDone[5] THEN
			FOR i := 1 TO 5 DO
				bMoveValveDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 2;
		END_IF

    2: // Calcula o numero de graus de rotacao das bombas baseado no tempo da receita Agitate Time 1

    	fAgitationTime  := TO_REAL(TIME_TO_DWORD(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time)/1000);
		fCalcDistance 	:= fAgitationTime * GVL_Motion.aPumps[1].Rotary.rSpeed;
		
		IF fCalcDistance <> 0 THEN
			iStepCounter := 3;
		END_IF
		
    3: // Inicia movimento rotativo com distância calculada (graus/seg -> steps) [negative moviment]
        FOR i := 1 TO 10 DO
			IF NOT bMovePumpDone[i] THEN
				bMovePumpDone[i] := GVL_Motion.aPumpsRotary[i].MoveRelative( Distance := - fCalcDistance,
																			 Velocity := GVL_Motion.aPumps[i].Rotary.rSpeed, 
																			 Acc := GVL_Motion.aPumps[i].Rotary.rAcceleration, 
																			 Dec := GVL_Motion.aPumps[i].Rotary.rDeceleration 
																			);
			END_IF
        END_FOR
		IF bMovePumpDone[1] AND bMovePumpDone[2] AND bMovePumpDone[3] AND bMovePumpDone[4] AND bMovePumpDone[5] AND bMovePumpDone[6] AND bMovePumpDone[7] AND bMovePumpDone[8] AND bMovePumpDone[9] AND bMovePumpDone[10] THEN
			FOR i := 1 TO 10 DO
				bMovePumpDone[i] := FALSE;
        	END_FOR
        	iStepCounter := 4; // Move to next step to monitor completion
		END_IF

    4: // Sets the movement done flag
		bMovementComplete := TRUE;
	
        
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Method Name="Reset" Id="{12eefff6-07c0-42e5-ab61-91712c03c502}">
      <Declaration><![CDATA[METHOD Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Action Name="ResetAll" Id="{b37c62b3-f3cd-48cf-8953-7840e35e64e5}">
      <Implementation>
        <ST><![CDATA[
// Reset solenoid control
fbSolenoidControl(bExecute := FALSE, eSolenoidSet := E_SolenoidSet.IDLE);

// Reset Timers
timerSoak(IN := FALSE, PT := T#0S);
timerAgitate(IN := FALSE, PT := T#0S);

// Reset Flags
bMovementComplete 	:= FALSE;
bInitComplete 		:= FALSE;
bDone 				:= FALSE;
eRecoveryState 		:= E_RecoveryState.Idle;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="SolventSoak" Id="{024c621c-c960-47f6-8737-9a73b1607501}">
      <Implementation>
        <ST><![CDATA[//Provide HMI animation details
GVL_HMI.HMIAnimation.sLoadTextRecovery := 'Solvent Soak'; 
GVL_HMI.HMIAnimation.rLoadBarRecovery  := 30;

// Initialize the Soak timer
bTimerStarted := TRUE;

IF timerSoak.Q THEN
	// Time completed, reset the timer
	bTimerStarted := FALSE;
	bSoakTimerDone := TRUE;
END_IF

// Wait for the timer to complete the time
timerSoak(IN := bTimerStarted, PT := GVL_Recipe.stActiveRecipe.stOtherParams.tSoakTime);

IF bSoakTimerDone THEN
	// Marks the end of the action
	bMovementComplete := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_RecoveryPhase">
      <LineId Id="741" Count="0" />
      <LineId Id="743" Count="0" />
      <LineId Id="748" Count="0" />
      <LineId Id="744" Count="0" />
      <LineId Id="742" Count="0" />
      <LineId Id="541" Count="3" />
      <LineId Id="739" Count="1" />
      <LineId Id="738" Count="0" />
      <LineId Id="745" Count="0" />
      <LineId Id="545" Count="10" />
      <LineId Id="728" Count="0" />
      <LineId Id="556" Count="1" />
      <LineId Id="719" Count="0" />
      <LineId Id="716" Count="0" />
      <LineId Id="559" Count="1" />
      <LineId Id="732" Count="0" />
      <LineId Id="561" Count="1" />
      <LineId Id="733" Count="0" />
      <LineId Id="563" Count="2" />
      <LineId Id="720" Count="0" />
      <LineId Id="566" Count="2" />
      <LineId Id="734" Count="0" />
      <LineId Id="569" Count="0" />
      <LineId Id="735" Count="0" />
      <LineId Id="570" Count="4" />
      <LineId Id="736" Count="0" />
      <LineId Id="575" Count="79" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1">
      <LineId Id="2" Count="46" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.CleaningLinesSolvent1and2">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.DisposeRemainingSolvent">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.FillAdditionalVials">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.GetPumpVolume">
      <LineId Id="10" Count="14" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent1">
      <LineId Id="216" Count="0" />
      <LineId Id="3" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="219" Count="2" />
      <LineId Id="218" Count="0" />
      <LineId Id="4" Count="2" />
      <LineId Id="204" Count="2" />
      <LineId Id="208" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="244" Count="3" />
      <LineId Id="242" Count="1" />
      <LineId Id="212" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="189" Count="1" />
      <LineId Id="188" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="222" Count="1" />
      <LineId Id="225" Count="5" />
      <LineId Id="232" Count="2" />
      <LineId Id="236" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="237" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="239" Count="0" />
      <LineId Id="192" Count="2" />
      <LineId Id="213" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="196" Count="4" />
      <LineId Id="195" Count="0" />
      <LineId Id="201" Count="2" />
      <LineId Id="72" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MeteringSolvent2">
      <LineId Id="84" Count="0" />
      <LineId Id="2" Count="81" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MixSolvent1and2">
      <LineId Id="87" Count="0" />
      <LineId Id="2" Count="7" />
      <LineId Id="86" Count="0" />
      <LineId Id="11" Count="74" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MoveToPosition">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.MoveToWastePosition">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.PrimeNeedles">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.RecirculateSolvent1">
      <LineId Id="152" Count="1" />
      <LineId Id="275" Count="1" />
      <LineId Id="274" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="277" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="239" Count="4" />
      <LineId Id="282" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="283" Count="0" />
      <LineId Id="246" Count="4" />
      <LineId Id="161" Count="2" />
      <LineId Id="251" Count="1" />
      <LineId Id="255" Count="4" />
      <LineId Id="253" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="261" Count="4" />
      <LineId Id="280" Count="0" />
      <LineId Id="266" Count="5" />
      <LineId Id="192" Count="2" />
      <LineId Id="272" Count="1" />
      <LineId Id="225" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.Reset">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.ResetAll">
      <LineId Id="33" Count="0" />
      <LineId Id="7" Count="2" />
      <LineId Id="25" Count="7" />
      <LineId Id="1" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_RecoveryPhase.SolventSoak">
      <LineId Id="33" Count="3" />
      <LineId Id="4" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="12" Count="2" />
      <LineId Id="16" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>