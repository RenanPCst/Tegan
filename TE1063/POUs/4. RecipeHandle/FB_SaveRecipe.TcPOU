<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_SaveRecipe" Id="{8d1bf021-741a-4d11-bf93-fed01591b205}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SaveRecipe
VAR_INPUT
    bExecute : BOOL;           // Trigger to start the save operation (level-sensitive)
    sUser    : STRING(64);     // Operator/user name to stamp into the recipe header
END_VAR
VAR_OUTPUT
    bDone    : BOOL;           // TRUE when the save operation completes successfully
    bBusy    : BOOL;           // TRUE while the state machine is running
    bError   : BOOL;           // TRUE if an error occurs in any file operation
    nErrId   : UDINT;          // Error code from file function blocks
END_VAR
VAR
    // --- State machine and helpers ---
    iStep         : INT;                       // Current state
    fbJson        : FB_JsonDomParser;          // JSON DOM builder
    sJsonBuffer   : STRING(8192);              // Output buffer for JSON serialization
    sFileName     : STRING(256);               // New file full path
    sOldFile      : STRING(256);               // Previous revision file path
    sOldBackup    : STRING(256);               // Backup path for previous revision
    sTempStr      : STRING(64);                // Temporary string for conversions
    iTempNumb     : DINT;                      // Temporary integer for conversions

    // --- File handling FBs ---
    fbFileOpen    : FB_FileOpen;
    fbFileWrite   : FB_FileWrite;
    fbFileClose   : FB_FileClose;
    fbFileRename  : FB_FileRename;
    nBytesToWrite : UDINT;                     // Number of bytes to write (excludes trailing 0)
    hFile         : UINT;                      // File handle

    // --- Date/Time stamping ---
    fbLocalSystemTime : FB_LocalSystemTime;    // Reads IPC local time
    sDate             : STRING(12);            // "D#YYYY-MM-DD" to convert with STRING_TO_DATE
    stLocalSystemTime : TIMESTRUCT;            // System time structure
    tzID              : E_TimeZoneID := eTimeZoneID_Invalid; // (Unused here; placeholder)

    // --- JSON nodes ---
    jsonRoot, objStInfo, objSolventsTimes, objVolumes, objOtherParams : SJsonValue;
    arrVal : SJsonValue;
    i : INT;

    // --- One-shot guards within a single execution ---
    bRevisionDone       : BOOL := FALSE;       // Ensures revision logic runs once per execution
    bGetCurrentDateDone : BOOL := FALSE;       // Ensures date capture runs once per execution
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// === STATE MACHINE ===
CASE iStep OF

// -------------------------------------------------------------
// 0: Idle / Entry. Wait for bExecute to start the save routine.
// -------------------------------------------------------------
0:
    IF bExecute THEN
        // Initialize outputs and flags
        bBusy  := TRUE;
        bDone  := FALSE;
        bError := FALSE;
        nErrId := 0;

        // --- Revision handling (run once) ---
        // If "New Recipe" button was used, start at revision 0.
        // Otherwise, increment the existing revision by 1.
        IF NOT bRevisionDone THEN
            IF GVL_HMI.bNewRecipeButton THEN
                GVL_Recipe.stCurrentRecipe.stInfo.iRevision := 0;
                bRevisionDone := TRUE;
            ELSE
                GVL_Recipe.stCurrentRecipe.stInfo.iRevision := GVL_Recipe.stCurrentRecipe.stInfo.iRevision + 1;
                bRevisionDone := TRUE;
            END_IF
        END_IF

        // --- Get local system date/time (run until valid once) ---
        // This block enables the clock reader and, when valid, produces TIMESTRUCT.
        fbLocalSystemTime(bEnable := TRUE, dwCycle := 5);
        IF fbLocalSystemTime.bValid THEN
            stLocalSystemTime := fbLocalSystemTime.systemTime;

            // Build date string "D#YYYY-MM-DD" required by STRING_TO_DATE
            sDate := CONCAT('D#', INT_TO_STRING(stLocalSystemTime.wYear));
            sDate := CONCAT(sDate, '-');
            sDate := CONCAT(sDate, INT_TO_STRING(stLocalSystemTime.wMonth));
            sDate := CONCAT(sDate, '-');
            sDate := CONCAT(sDate, INT_TO_STRING(stLocalSystemTime.wDay));

            // Persist date into recipe header (DATE type)
            GVL_Recipe.stCurrentRecipe.stInfo.dCreationDate := STRING_TO_DATE(sDate);
            bGetCurrentDateDone := TRUE;
        END_IF

        // Only proceed once date/time was captured
        IF bGetCurrentDateDone THEN

            // Stamp the creator name
            GVL_Recipe.stCurrentRecipe.stInfo.sCreatedBy := sUser;

            // --- Compose file names ---
            // New file: .../<Method>_<User>_rev<Revision>.json
            sFileName := CONCAT('C:/TwinCAT/Recipes/',
                CONCAT(GVL_Recipe.stCurrentRecipe.stInfo.sMethodName, CONCAT('_',
                CONCAT(sUser, CONCAT('_rev', CONCAT(DINT_TO_STRING(GVL_Recipe.stCurrentRecipe.stInfo.iRevision), '.json')))))
            );

            // Previous file (revision-1) for backup (no fatal error if it doesn't exist)
            sOldFile := CONCAT('C:/TwinCAT/Recipes/',
                CONCAT(GVL_Recipe.stCurrentRecipe.stInfo.sMethodName, CONCAT('_',
                CONCAT(sUser, CONCAT('_rev', CONCAT(DINT_TO_STRING(GVL_Recipe.stCurrentRecipe.stInfo.iRevision - 1), '.json')))))
            );

            // Backup path for the previous file
            sOldBackup := CONCAT('C:/TwinCAT/Recipes/_old/',
                CONCAT(GVL_Recipe.stCurrentRecipe.stInfo.sMethodName, CONCAT('_',
                CONCAT(sUser, CONCAT('_rev', CONCAT(DINT_TO_STRING(GVL_Recipe.stCurrentRecipe.stInfo.iRevision - 1), '.json')))))
            );

            // --- Build JSON document ---
            jsonRoot := fbJson.NewDocument();

            // Header: stInfo
            objStInfo := fbJson.AddObjectMember(jsonRoot, 'stInfo');
            fbJson.AddStringMember(objStInfo, 'sMethodName', GVL_Recipe.stCurrentRecipe.stInfo.sMethodName);
            fbJson.AddIntMember   (objStInfo, 'iRevision',   GVL_Recipe.stCurrentRecipe.stInfo.iRevision);
            fbJson.AddStringMember(objStInfo, 'sCreatedBy',  GVL_Recipe.stCurrentRecipe.stInfo.sCreatedBy);
            sTempStr := DATE_TO_STRING(GVL_Recipe.stCurrentRecipe.stInfo.dCreationDate);
            fbJson.AddStringMember(objStInfo, 'dCreationDate', sTempStr);

            // stSolventsTimes
            objSolventsTimes := fbJson.AddObjectMember(jsonRoot, 'stSolventsTimes');

            // aSolventN[1..4] as integer array
            arrVal := fbJson.AddArrayMember(objSolventsTimes, 'aSolventN', 0);
            FOR i := 1 TO 4 DO
                fbJson.PushbackIntValue(arrVal, GVL_Recipe.stCurrentRecipe.stSolventsTimes.aSolventN[i]);
            END_FOR

            // aTime[1..4] as stringified TIME array (e.g., "T#10S")
            arrVal := fbJson.AddArrayMember(objSolventsTimes, 'aTime', 0);
            FOR i := 1 TO 4 DO
                sTempStr := TIME_TO_STRING(GVL_Recipe.stCurrentRecipe.stSolventsTimes.aTime[i]);
                fbJson.PushbackStringValue(arrVal, sTempStr);
            END_FOR

            // aVelocity[1..4] as integer array
            arrVal := fbJson.AddArrayMember(objSolventsTimes, 'aVelocity', 0);
            FOR i := 1 TO 4 DO
                fbJson.PushbackIntValue(arrVal, GVL_Recipe.stCurrentRecipe.stSolventsTimes.aVelocity[i]);
            END_FOR

            // stVolumes (multiple double arrays, each [1..4])
            objVolumes := fbJson.AddObjectMember(jsonRoot, 'stVolumes');

            arrVal := fbJson.AddArrayMember(objVolumes, 'aT_IC_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aT_IC_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS0_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS0_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS1_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS1_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS2_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS2_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS3_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS3_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS4_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS4_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS5_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS5_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS6_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS6_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aS7_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aS7_Volume[i]); END_FOR

            arrVal := fbJson.AddArrayMember(objVolumes, 'aF_Volume', 0);
            FOR i := 1 TO 4 DO fbJson.PushbackDoubleValue(arrVal, GVL_Recipe.stCurrentRecipe.stVolumes.aF_Volume[i]); END_FOR

            // stOtherParams
            objOtherParams := fbJson.AddObjectMember(jsonRoot, 'stOtherParams');

            sTempStr := TIME_TO_STRING(GVL_Recipe.stCurrentRecipe.stOtherParams.tSoakTime);
            fbJson.AddStringMember(objOtherParams, 'tSoakTime', sTempStr);

            sTempStr := TIME_TO_STRING(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate1Time);
            fbJson.AddStringMember(objOtherParams, 'tAgitate1Time', sTempStr);

            sTempStr := TIME_TO_STRING(GVL_Recipe.stCurrentRecipe.stOtherParams.tAgitate2Time);
            fbJson.AddStringMember(objOtherParams, 'tAgitate2Time', sTempStr);

            iTempNumb := TO_DINT(GVL_Recipe.stCurrentRecipe.stOtherParams.iVialsToFill);
            fbJson.AddIntMember(objOtherParams, 'iVialsToFill', iTempNumb);

            fbJson.AddDoubleMember(objOtherParams, 'rVialPrimeVol',   GVL_Recipe.stCurrentRecipe.stOtherParams.rVialPrimeVol);
            fbJson.AddDoubleMember(objOtherParams, 'rVial1FillVol',   GVL_Recipe.stCurrentRecipe.stOtherParams.rVial1FillVol);
            fbJson.AddDoubleMember(objOtherParams, 'rVials2_4FillVol', GVL_Recipe.stCurrentRecipe.stOtherParams.rVials2_4FillVol);

            sTempStr := TIME_TO_STRING(GVL_Recipe.stCurrentRecipe.stOtherParams.tAirDryTime);
            fbJson.AddStringMember(objOtherParams, 'tAirDryTime', sTempStr);

            // Serialize to buffer (also useful to precompute length)
            fbJson.CopyDocument(sJsonBuffer, SIZEOF(sJsonBuffer));

            // Ensure any previous rename FB is idle before proceeding
            fbFileRename(bExecute := FALSE);

            // Next step: try moving the old file to backup
            iStep := 5;
        END_IF
    END_IF

// -------------------------------------------------------------
// 5: Move old file to _old backup (non-fatal if not present).
//    Proceeds regardless of success; we don't block new save.
// -------------------------------------------------------------
5:
    fbFileRename(
        sNetId   := '',
        sOldName := sOldFile,
        sNewName := sOldBackup,
        bExecute := TRUE
    );

    // Make sure open FB is idle before reusing it later
    fbFileOpen(bExecute := FALSE);

    IF NOT fbFileRename.bBusy THEN
        // Ignore fbFileRename.bError intentionally: absence is acceptable
        iStep := 10;
    END_IF

// -------------------------------------------------------------
// 10: Create/open the new file for text write.
// -------------------------------------------------------------
10:
    fbFileOpen(
        sNetId    := '',
        sPathName := sFileName,
        nMode     := FOPEN_MODEWRITE OR FOPEN_MODETEXT, // Overwrite text file
        bExecute  := TRUE
    );

    // Keep write FB idle until we have a valid handle
    fbFileWrite(bExecute := FALSE);

    IF NOT fbFileOpen.bBusy THEN
        IF fbFileOpen.bError THEN
            bError := TRUE;
            nErrId := fbFileOpen.nErrId;
            iStep  := 100; // Go to end; wait for bExecute to drop
        ELSE
            hFile := fbFileOpen.hFile; // Store file handle
            iStep := 20;               // Proceed to write
        END_IF
    END_IF

// -------------------------------------------------------------
// 20: Write the serialized JSON buffer to disk.
// -------------------------------------------------------------
20:
    // Refresh serialized content and compute exact byte count (without trailing #0)
    nBytesToWrite := fbJson.CopyDocument(sJsonBuffer, SIZEOF(sJsonBuffer));
    IF nBytesToWrite > 0 THEN
        nBytesToWrite := nBytesToWrite - 1; // Exclude terminating null
    END_IF

    fbFileWrite(
        sNetId     := '',
        hFile      := hFile,
        pWriteBuff := ADR(sJsonBuffer),
        cbWriteLen := nBytesToWrite,
        bExecute   := TRUE
    );

    // Prepare close FB (idle for now)
    fbFileClose(bExecute := FALSE);

    IF NOT fbFileWrite.bBusy THEN
        IF fbFileWrite.bError THEN
            bError := TRUE;
            nErrId := fbFileWrite.nErrId;
            iStep  := 100; // Error path
        ELSE
            iStep := 30;   // Proceed to close
        END_IF
    END_IF

// -------------------------------------------------------------
// 30: Close the file, finalize flags, and finish.
// -------------------------------------------------------------
30:
    fbFileClose(
        sNetId   := '',
        hFile    := hFile,
        bExecute := TRUE
    );

    IF NOT fbFileClose.bBusy THEN
        IF fbFileClose.bError THEN
            bError := TRUE;
            nErrId := fbFileClose.nErrId;
        END_IF

        // Reset one-shot flags for a clean next cycle
        bGetCurrentDateDone := FALSE;
        GVL_HMI.bNewRecipeButton := FALSE;
        bRevisionDone := FALSE;

        // Mark completion
        bDone := TRUE;
        bBusy := FALSE;

        // Go to final state; wait for bExecute to drop
        iStep := 100;
    END_IF

// -------------------------------------------------------------
// 100: Final/hold state. Wait for bExecute to go FALSE to reset.
// -------------------------------------------------------------
100:
    IF NOT bExecute THEN
        // Reset to idle
        iStep := 0;

        // Clear guards and outputs to be ready for next run
        bRevisionDone       := FALSE;
        bGetCurrentDateDone := FALSE;
        bDone  := FALSE;
        bBusy  := FALSE;
        // bError/nErrId are intentionally kept until next run starts
    END_IF

END_CASE]]></ST>
    </Implementation>
    <LineIds Name="FB_SaveRecipe">
      <LineId Id="341" Count="0" />
      <LineId Id="803" Count="288" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>