<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="PRG_StateMachine" Id="{3698ba7e-335b-4575-b74b-b2c2009fcddd}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_StateMachine
VAR
	Inputs_EL1809 		: ST_EL1809; 
    Outputs_EL2809 		: ST_EL2809; 
    AnalogInputs_EL3058 : ST_EL3058; 

    CurrentState 	: E_MachineStates; 
    bErrorFlag		: BOOL; 
	bPowerUpTimerComplete : BOOL;
	
	//Initialization stage
	fbInitChecks			: FB_InitChecks; //FB Reponsible for the Init state Logic
		bPowerUpComplete	: BOOL := FALSE; //Flag response to the FB_InitChecks
	
	//Air Flow Variables
	FB_AirFlowCheck 		: FB_AirFlowCheck;  //FB instance
		bAirSupplyStable 	: BOOL;   		//Stable air flow flag
		bAirSupplyError		: BOOL;      	//Air flow error flag
		rAirSupplyNow		: LREAL;		//Instant air flow meassure
	
	tonPowerUp		: 	Tc2_Standard.TON;
	TON_Monitor 	: 	Tc2_Standard.TON;
	ValveController : 	FB_ValvePositionControl;//valve controller instance
    iLoopIndex 		: 	INT := 1; 				//Índice do loop atual)
	iSolenoidIndex 	: 	INT;
	
	//Recovery Phase Variables
	RecoveryPhaseFB 	: FB_RecoveryPhase;    				//recevory fb instance
	aSolenoidSets 		: ARRAY [1..5] OF ST_SolenoidSet;	//solenoids sets
    bRecoverySuccess 	: BOOL;               				//recovery sucess flag
    bRecoveryError 		: BOOL;                 			//recovery error flag 
	
	MotorStageCollection 	: FB_StageCollectionMotor; 		//FB motors intance 
    MotorAxis 				: AXIS_REF;                		//motor reference 
    MotorInPosition 		: BOOL;                    		//motor in position flag
    MotorBusy 				: BOOL;                         //motor moving flag
    MotorError 				: BOOL;                         //motor error flag
    MotorErrorID 			: UDINT;                        //motor error id						
	
	//others FB Instances
	FB_SealStages 		: FB_SealStages;
		bSealSuccess	: BOOL := FALSE; //seal sucess flag FB_SealStages
		bSealError		: BOOL := FALSE; //seal error flag FB_SealStages
		
	FB_LeakTest		:	FB_LeakTest;
	
	E_MachineState			: INT;
	
	// Event/Alarm Trigger Variables
	fbEventHandler : FB_EventHandler;
		bExecuteEvent	: BOOL := FALSE;
		bEventDone 		: BOOL := FALSE;
		sSystem			: STRING(256);
		sMessage		: STRING(256);
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//System Power Up Timer
tonPowerUp( IN 	:= TRUE, 
			PT 	:= T#2S,	
			Q 	=> bPowerUpTimerComplete);

IF bPowerUpTimerComplete THEN
	CurrentState := E_MachineStates.INIT; 
END_IF
			
//Sequence
CASE CurrentState OF
    E_MachineStates.INIT: //Initialization stage - checking powersuply, doors and air supply
	
		//Event Trigger Info State - Checking Initialization
		sSystem := 'StateMachine.INIT'; sMessage := 'Cheking Safe Conditions!';
		fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.INFO, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
    	ResetEventTrigger();
		
		//Calling the FB responsible for check all condition for initial operation	
        FB_InitChecks(
			bPower24V_OK  := GVL_IO.gDigInputs.b24VPowerSupplyOK,
			bPower48V_OK  := GVL_IO.gDigInputs.b48VPowerSupplyOK,
			bDoorsClosed  := GVL_Safety.bDoorClosedAlias,
			bDoorsLocked  := GVL_Safety.bDoorLockedFeedback,
			bAirEnabled   := GVL_Safety.bAirEnabledFeedback,
			bInitOK       => bPowerUpComplete,
			bError        => bErrorFlag
		);
		//State Transition
		IF bErrorFlag THEN
			//Event Trigger Info State - Initialization Done
			sSystem := 'StateMachine.INIT'; sMessage := 'Initialization fail - Going to Error State!';
			fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.ERROR, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
			ResetEventTrigger();
			//State Trasition to ERROR_STATE
			CurrentState := E_MachineStates.ERROR_STATE;
		ELSIF bPowerUpComplete THEN
			//Event Trigger Info State - Initialization Done
			sSystem := 'StateMachine.INIT'; sMessage := 'Initialization Successful!';
			fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.INFO, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
			ResetEventTrigger();
			//State Trasition to CHECK_AIR_FLOW
			CurrentState := E_MachineStates.CHECK_AIR_FLOW;
		END_IF;

    E_MachineStates.CHECK_AIR_FLOW: //Checking is the air supply is higher than the air supply threshold
	
		// 1. Check if the pressure sensor reports an error
		IF GVL_IO.gAnalogInputs.bPressureRegulatorError THEN
			//Trigger Error Event
			fbEventHandler(
				bExecute  	:= bExecuteEvent,
				eEventName 	:= E_Events.ERROR,
				sSystem    	:= 'Air Supply Check',
				sMessage   	:= 'Air Supply Sensor Error State!',
				bDone      	=> bEventDone
			);
			ResetEventTrigger(); //Reset the Error Event
			
			//Going to error state
			CurrentState := E_MachineStates.ERROR_STATE;
			GVL_IO.gDigOutputs.bTowerRedLight := TRUE; // Activate alarm
			bAirSupplyError := TRUE;
		ELSE
			// 2. Execute the airflow verification
			FB_AirFlowCheck(
				iRawSensorValue    	:= GVL_IO.gAnalogInputs.rMainPressureSupplyInput, // Raw sensor value
				iSensorID          	:= 1, // FESTO Air supply Pressure sensor Id
				rPressureThreshold 	:= GVL_MachineParam.rAirSupplyThreshold,
				tStabilizationTime 	:= GVL_MachineParam.rAirSupplyTestingTime,
				bExecute           	:= TRUE,
				bAirFlowOK			=> bAirSupplyStable,
				bAirFlowError		=> bAirSupplyError
			);
		
			// 3. State transitions
			IF bAirSupplyError THEN
				CurrentState := E_MachineStates.ERROR_STATE;
				GVL_IO.gDigOutputs.bTowerRedLight := TRUE; // Activate alarm
			ELSIF bAirSupplyStable THEN
				//Trigger info Event
				fbEventHandler(
					bExecute  	:= bExecuteEvent,
					eEventName 	:= E_Events.INFO,
					sSystem    	:= 'Air Supply Check',
					sMessage   	:= 'Air Supply OK!',
					bDone      	=> bEventDone
				);
				ResetEventTrigger(); //Reset the Error Event
				CurrentState := E_MachineStates.HARDWARE_INIT; // Move to the next state
			END_IF;
		END_IF;	

    E_MachineStates.HARDWARE_INIT:
        IF TRUE THEN //checking all hardware. testing pumps and valves etc.
            CurrentState 	:= E_MachineStates.SEAL_STAGES;
        ELSE
            bErrorFlag 		:= TRUE;
            CurrentState	:= E_MachineStates.ERROR_STATE;
        END_IF;

    E_MachineStates.SEAL_STAGES:
		//temporary until we are able to get this parameter from hmi
		GVL_MachineParam.aM1Position[2] := 100;
		
		//calling the FB_SealStages
		IF GVL_Safety.bM1STOEnabled THEN
			FB_SealStages(
				Axis				:= GVL_Motion.M1Motor.Axis,
				iTargetPosition		:= GVL_MachineParam.aM1Position[2], //Seal Position
				rVelocity			:= GVL_Motion.M1Motor.qTargetVelocity,
				rAcceleration		:= GVL_Motion.M1Motor.rAccleration,
				rDeceleration		:= GVL_Motion.M1Motor.rDeceleration,
				bExecute 			:= TRUE,
				bSealSucess			=> bSealSuccess,
				bSealError			=> bSealError
			);
		END_IF
		
		//error check
		IF NOT bSealSuccess AND bSealError THEN
			//error dealing logic
			GVL_IO.gDigOutputs.bTowerRedLight := TRUE; //raise alarm/red light
			CurrentState := E_MachineStates.ERROR_STATE;
		END_IF;

		//step forward to step ahead
		IF bSealSuccess AND NOT bSealError THEN
			CurrentState := E_MachineStates.LEAK_TEST; //step forward to step ahead
		END_IF;

    E_MachineStates.LEAK_TEST: //Leaking test on 10 loops

		(*
		//Call FB responsible for take the leak test on all loops.
		FB_LeakTest(
			aSolenoidSets 		:= ValveConfigs.aSolenoidSets,
			aValveConfigs		:= ValveConfigs.aValvePositions,
			rPressureThreshold 	:= ValveConfigs.rPressureThreshold,
			tMonitoringTime 	:= ValveConfigs.tMonitoringTime,
			rMainPressureSupply := GVL_IO.gAnalogInputs.rMainPressureSupplyInput,
			iLoopIndex 			:= iLoopIndex,
			bExecute 			:= TRUE
		);
	
		//check the results from FB_LeakTest
		IF FB_LeakTest.bLeakTestError THEN
			CurrentState := E_MachineStates.ERROR_STATE;
		ELSIF FB_LeakTest.bLeakTestSucess THEN
			IF iLoopIndex < 10 THEN
				iLoopIndex := iLoopIndex + 1;
				CurrentState := E_MachineStates.LEAK_TEST;
			ELSE
				CurrentState := E_MachineStates.RECOVERY_PHASE;
				iLoopIndex := 1;
			END_IF;
		END_IF;
	*)

    E_MachineStates.RECOVERY_PHASE:
        //Setup and execute FB_RecoveryPhase
        RecoveryPhaseFB(
            RecipeParameters := GVL_RecipeParameters,  	//recipe parameters reference 
            aValveConfigs := ValveConfigs,             	//6position valves reference
            aSolenoidSets := aSolenoidSets,            	//passing solenoids sets 
            bExecute := TRUE                           	//init trigger
        );

        //checking the RecoveryPhaseFB results
        bRecoverySuccess := RecoveryPhaseFB.bSuccess;
        bRecoveryError := RecoveryPhaseFB.bError;

        //state transitions based oon fb returns
        IF bRecoveryError THEN
            CurrentState := E_MachineStates.ERROR_STATE;
            GVL_IO.gDigOutputs.bTowerRedLight := TRUE; //raise alarm/red light
        ELSIF bRecoverySuccess THEN
            CurrentState := E_MachineStates.DRYING_PHASE; //step forward to step ahead
        END_IF;

    E_MachineStates.WASHING_PHASE: //TODO
        IF TRUE THEN //washing sequence
            CurrentState := E_MachineStates.DRYING_PHASE;
        ELSE
            bErrorFlag := TRUE;
            CurrentState := E_MachineStates.ERROR_STATE;
        END_IF;

    E_MachineStates.DRYING_PHASE: //TODO
        IF TRUE THEN //drying sequence
            CurrentState := E_MachineStates.POST_EXECUTION;
        ELSE
            bErrorFlag := TRUE;
            CurrentState := E_MachineStates.ERROR_STATE;
        END_IF;

    E_MachineStates.POST_EXECUTION: //TODO
        IF TRUE THEN //post execution sequence
            CurrentState := E_MachineStates.INIT;
        ELSE
            bErrorFlag := TRUE;
            CurrentState := E_MachineStates.ERROR_STATE;
        END_IF;

    E_MachineStates.ERROR_STATE: //TODO
        GVL_IO.gDigOutputs.bTowerRedLight := TRUE; //red light
		
		//Event Trigger Info State - Error State
		sSystem := 'StateMachine.Error'; sMessage := 'Error State!';
		fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.ERROR, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
		ResetEventTrigger();
		
        IF GVL_IO.gDigInputs.bStopButton THEN
            bErrorFlag := FALSE;
            CurrentState := E_MachineStates.INIT;
        END_IF;
END_CASE;]]></ST>
    </Implementation>
    <Action Name="ResetEventTrigger" Id="{2d5034a6-643b-4aff-aeda-4e9dc3f48beb}">
      <Implementation>
        <ST><![CDATA[IF bEventDone THEN
        bExecuteEvent := FALSE;
        bEventDone := FALSE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="PRG_StateMachine">
      <LineId Id="295" Count="0" />
      <LineId Id="293" Count="0" />
      <LineId Id="300" Count="2" />
      <LineId Id="294" Count="0" />
      <LineId Id="304" Count="1" />
      <LineId Id="303" Count="0" />
      <LineId Id="291" Count="0" />
      <LineId Id="212" Count="1" />
      <LineId Id="789" Count="0" />
      <LineId Id="771" Count="0" />
      <LineId Id="792" Count="0" />
      <LineId Id="782" Count="0" />
      <LineId Id="781" Count="0" />
      <LineId Id="779" Count="0" />
      <LineId Id="778" Count="0" />
      <LineId Id="709" Count="10" />
      <LineId Id="807" Count="2" />
      <LineId Id="806" Count="0" />
      <LineId Id="810" Count="0" />
      <LineId Id="720" Count="1" />
      <LineId Id="795" Count="2" />
      <LineId Id="794" Count="0" />
      <LineId Id="798" Count="1" />
      <LineId Id="219" Count="2" />
      <LineId Id="927" Count="0" />
      <LineId Id="898" Count="1" />
      <LineId Id="939" Count="0" />
      <LineId Id="929" Count="6" />
      <LineId Id="928" Count="0" />
      <LineId Id="937" Count="1" />
      <LineId Id="900" Count="2" />
      <LineId Id="904" Count="7" />
      <LineId Id="925" Count="1" />
      <LineId Id="912" Count="1" />
      <LineId Id="918" Count="4" />
      <LineId Id="945" Count="7" />
      <LineId Id="943" Count="0" />
      <LineId Id="923" Count="1" />
      <LineId Id="227" Count="10" />
      <LineId Id="652" Count="2" />
      <LineId Id="643" Count="0" />
      <LineId Id="440" Count="0" />
      <LineId Id="432" Count="0" />
      <LineId Id="591" Count="0" />
      <LineId Id="594" Count="4" />
      <LineId Id="646" Count="1" />
      <LineId Id="592" Count="0" />
      <LineId Id="644" Count="0" />
      <LineId Id="433" Count="0" />
      <LineId Id="394" Count="2" />
      <LineId Id="651" Count="0" />
      <LineId Id="397" Count="0" />
      <LineId Id="399" Count="4" />
      <LineId Id="243" Count="2" />
      <LineId Id="699" Count="0" />
      <LineId Id="444" Count="3" />
      <LineId Id="468" Count="0" />
      <LineId Id="448" Count="18" />
      <LineId Id="251" Count="2" />
      <LineId Id="530" Count="17" />
      <LineId Id="259" Count="27" />
      <LineId Id="801" Count="0" />
      <LineId Id="804" Count="0" />
      <LineId Id="802" Count="1" />
      <LineId Id="800" Count="0" />
      <LineId Id="805" Count="0" />
      <LineId Id="287" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_StateMachine.ResetEventTrigger">
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>