<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="PRG_StateMachine" Id="{3698ba7e-335b-4575-b74b-b2c2009fcddd}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_StateMachine
VAR
    CurrentState 	: E_MachineStates; 
    bErrorFlag		: BOOL; 
	bPowerUpDone	: BOOL := FALSE;
	tonPowerUp		: Tc2_Standard.TON;
	bPowerUpTimerComplete : BOOL; //Initialization timer
	
	
	//Initialization stage
	fbInitChecks			: FB_InitChecks; 	//FB Reponsible for the Init state Logic
		bPowerUpComplete	: BOOL := FALSE; 	//Flag response to the FB_InitChecks
	
	//Hardware Initialization Instance
	fbHardwareInit :	FB_HardwareInit;
		
	//Air Flow Variables
	fbAirFlowCheck 		: FB_AirFlowCheck;  	//FB instance
		bAirSupplyStable 	: BOOL;   			//Stable air flow flag
		bAirSupplyError		: BOOL;      		//Air flow error flag
		rAirSupplyNow		: LREAL;			//Instant air flow meassure
	
	//Recovery Phase Variables
	fbRecoveryPhase 	: FB_RecoveryPhase;    					//recevory fb instance
		aSolenoidSets 		:  ST_SolenoidSet;					//solenoids sets
		bRecoverySuccess 	: BOOL;               				//recovery sucess flag
		bRecoveryError 		: BOOL;                 			//recovery error flag 						
		
	//Seal Stages Instance
	fbSealStagesP1 		: FB_SealStages;	//FB instance
		bSealSuccessP1	: BOOL := FALSE; 	//seal sucess flag FB_SealStages
		bSealErrorP1	: BOOL := FALSE; 	//seal error flag FB_SealStages
	fbSealStagesP2 		: FB_SealStages;	//FB instance
		bSealSuccessP2	: BOOL := FALSE; 	//seal sucess flag FB_SealStages
		bSealErrorP2	: BOOL := FALSE; 	//seal error flag FB_SealStages
		tonSealStages	: TON;
		
	//Leak Test Instance
	fbLeakTest		:	FB_LeakTest;
		bTestCompleted		: BOOL 	 := FALSE;
		bTestFailed			: BOOL 	 := FALSE;
		sTestErrorMessage 	: STRING := '';
		
	// Event/Alarm Trigger Variables
	fbEventHandler : FB_EventHandler;
		bExecuteEvent	: BOOL := FALSE;
		bEventDone 		: BOOL := FALSE;
		sSystem			: STRING(256);
		sMessage		: STRING(256);
		
	//Debug variables
	bStatePass1	: BOOL := FALSE;
	bStatePass2	: BOOL := FALSE;
	bStatePass3	: BOOL := FALSE;
	bStatePass4	: BOOL := FALSE;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//System Power Up Timer
tonPowerUp( IN 	:= TRUE, 
			PT 	:= T#2S,	
			Q 	=> bPowerUpTimerComplete);

IF bPowerUpTimerComplete AND NOT bPowerUpDone THEN
	CurrentState := E_MachineStates.UNINITIALIZED;
	bPowerUpDone := TRUE; // Indicates que the initialization is already happened
END_IF

// If the reset signal is TRUE or the stop button is pressed, it returns to UNINITIALIZED
IF NOT GVL_Safety.bSafetyEnable OR NOT GVL_IO.gDigInputs.bStopButton THEN
	CurrentState := E_MachineStates.UNINITIALIZED;
END_IF;

//Sequence
CASE CurrentState OF
	
	E_MachineStates.UNINITIALIZED:
	
		//Turns on the start button
		IF GVL_Safety.bSafetyEnable THEN
			GVL_IO.gDigOutputs.bStartIndicator := TRUE;
		ELSE
			GVL_IO.gDigOutputs.bStartIndicator := FALSE;
		END_IF
		// It only advances to INIT if there is no reset signal and the start button is pressed
		
		IF GVL_Safety.bSafetyEnable AND GVL_IO.gDigInputs.bStartButton THEN
			CurrentState := E_MachineStates.INIT;
		END_IF;

    E_MachineStates.INIT: 	//Initialization stage - checking powersuply, doors and air supply
	
		GVL_IO.gDigOutputs.bStartIndicator := FALSE; //Turn of the start indicator once the system already started
		//IF bStatePass1 THEN 	//temporary Debug Manual variable ************************************************************************************
			//Event Trigger Info State - Checking Initialization
			sSystem := 'StateMachine.INIT'; sMessage := 'Cheking Safe Conditions!';
			fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.INFO, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
			ResetEventTrigger();
			
			//Calling the FB responsible for check all condition for initial operation	
			fbInitChecks(
				bPower24V_OK  := GVL_IO.gDigInputs.b24VPowerSupplyOK,
				bPower48V_OK  := GVL_IO.gDigInputs.b48VPowerSupplyOK,
				bDoorsClosed  := GVL_Safety.bDoorClosedAlias,
				bDoorsLocked  := GVL_Safety.bDoorLockedFeedback,
				bAirEnabled   := GVL_Safety.SafetyOutputs.bBelowDoorsFeedback,//#TODO GVL_Safety.bAirEnabledFeedback, AirSupply not working implemented valve feedback no working
				bInitOK       => bPowerUpComplete,
				bError        => bErrorFlag
			);
			//State Transition
			IF bErrorFlag THEN
				//Event Trigger Info State - Initialization Done
				sSystem := 'StateMachine.INIT'; sMessage := 'Initialization fail - Going to Error State!';
				fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.ERROR, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
				ResetEventTrigger();
				//State Trasition to ERROR_STATE
				CurrentState := E_MachineStates.ERROR_STATE;
			ELSIF bPowerUpComplete THEN
				//Event Trigger Info State - Initialization Done
				sSystem := 'StateMachine.INIT'; sMessage := 'Initialization Successful!';
				fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.INFO, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
				ResetEventTrigger();
				//State Trasition to CHECK_AIR_FLOW
				CurrentState := E_MachineStates.CHECK_AIR_FLOW;
			END_IF;
		//END_IF//temporary Debug Manual variable *************************************************************************************************
    
	E_MachineStates.CHECK_AIR_FLOW: //Checking is the air supply is higher than the air supply threshold
	
		//IF bStatePass2 THEN//temporary Debug Manual variable ************************************************************************************
			// 1. Check if the pressure sensor reports an error
			IF GVL_IO.gAnalogInputs.bPressureRegulatorError THEN
				//Trigger Error Event
				fbEventHandler(
					bExecute  	:= bExecuteEvent,
					eEventName 	:= E_Events.ERROR,
					sSystem    	:= 'Air Supply Check',
					sMessage   	:= 'Air Supply Sensor Error State!',
					bDone      	=> bEventDone
				);
				ResetEventTrigger(); //Reset the Error Event
				
				//Going to error state
				CurrentState := E_MachineStates.ERROR_STATE;
				GVL_IO.gDigOutputs.bTowerRedLight := TRUE; // Activate alarm
				bAirSupplyError := TRUE;
			ELSE
				// 2. Execute the airflow verification
				fbAirFlowCheck(
					iRawSensorValue    	:= GVL_IO.gAnalogInputs.rMainPressureSupplyInput, // Raw sensor value
					iSensorID          	:= 1, // FESTO Air supply Pressure sensor Id
					rPressureThreshold 	:= GVL_Settings.rAirSupplyThreshold,
					tStabilizationTime 	:= GVL_Settings.rAirSupplyTestingTime,
					bExecute           	:= TRUE,
					bAirFlowOK			=> bAirSupplyStable,
					bAirFlowError		=> bAirSupplyError
				);
			
				// 3. State transitions
				IF bAirSupplyError THEN
					CurrentState := E_MachineStates.ERROR_STATE;
					GVL_IO.gDigOutputs.bTowerRedLight := TRUE; // Activate alarm
				ELSIF bAirSupplyStable THEN
					//Trigger info Event
					fbEventHandler(
						bExecute  	:= bExecuteEvent,
						eEventName 	:= E_Events.INFO,
						sSystem    	:= 'Air Supply Check',
						sMessage   	:= 'Air Supply OK!',
						bDone      	=> bEventDone
					);
					ResetEventTrigger(); //Reset the Error Event
					CurrentState := E_MachineStates.HARDWARE_INIT; // Move to the next state
				END_IF;
			END_IF;	
		//END_IF//temporary Debug Manual variable ************************************************************************************
		
    E_MachineStates.HARDWARE_INIT: //Initiate the motors M1 - M3 going to home position sensor e then get zero position. M4 -> M8 valves going to position 1.
		//IF bStatePass3 THEN//temporary Debug Manual variable ************************************************************************************
			fbHardwareInit( bExecute := TRUE );
			//State Transition
			IF fbHardwareInit.bError THEN
				CurrentState := E_MachineStates.ERROR_STATE;
			END_IF;
			IF fbHardwareInit.bDone THEN
				CurrentState := E_MachineStates.SEAL_STAGES;
			END_IF;
		//END_IF//temporary Debug Manual variable ************************************************************************************
		
    E_MachineStates.SEAL_STAGES:

			//temporary until we are able to get this parameter from hmi
			GVL_Settings.aM1Position[2] 			:= -300;
			GVL_Settings.aM1Position[3] 			:= -330;
			GVL_Motion.M1Motor.rTargetVelocityP1 	:= 20;
			GVL_Motion.M1Motor.rTargetVelocityP2 	:= 5;
			GVL_Motion.M1Motor.rAccleration 		:= 10;
			GVL_Motion.M1Motor.rDeceleration 		:= 5;
			
			//calling the FB_SealStages
			IF GVL_Safety.bM1STOEnabled THEN
				fbSealStagesP1(
					Axis				:= GVL_Motion.M1Motor.Axis,
					iTargetPosition		:= GVL_Settings.aM1Position[2], //Seal Position
					rVelocity			:= GVL_Motion.M1Motor.rTargetVelocityP1,
					rAcceleration		:= GVL_Motion.M1Motor.rAccleration,
					rDeceleration		:= GVL_Motion.M1Motor.rDeceleration,
					bExecute 			:= TRUE,
					bSealSucess			=> bSealSuccessP1,
					bSealError			=> bSealErrorP1
				);
			END_IF
			IF bSealSuccessP1 THEN
				tonSealStages(IN := TRUE, PT := T#500MS);
			END_IF
			IF GVL_Safety.bM1STOEnabled AND tonSealStages.Q THEN
				fbSealStagesP2(
					Axis				:= GVL_Motion.M1Motor.Axis,
					iTargetPosition		:= GVL_Settings.aM1Position[3], //Seal Position
					rVelocity			:= GVL_Motion.M1Motor.rTargetVelocityP2,
					rAcceleration		:= GVL_Motion.M1Motor.rAccleration,
					rDeceleration		:= GVL_Motion.M1Motor.rDeceleration,
					bExecute 			:= TRUE,
					bSealSucess			=> bSealSuccessP2,
					bSealError			=> bSealErrorP2
				);
			END_IF
			
			//error check
			IF (NOT bSealSuccessP1 OR NOT bSealSuccessP2) AND (bSealErrorP1 OR bSealErrorP2)  THEN
				//error dealing logic
				GVL_IO.gDigOutputs.bTowerRedLight := TRUE; //raise alarm/red light
				CurrentState := E_MachineStates.ERROR_STATE;
			END_IF;
	
			//step forward to step ahead
			IF bSealSuccessP1 AND bSealSuccessP2 AND NOT bSealErrorP1 AND NOT bSealErrorP2 THEN
				CurrentState := E_MachineStates.LEAK_TEST; //step forward to step ahead
			END_IF;

	E_MachineStates.LEAK_TEST: //Leaking test on 10 loops
		(*// Call the Leak Test function block
        fbLeakTest(
            bExecute := TRUE,
            eSolenoidPosition := E_SolenoidSet.LEAKTEST, // Set solenoids to leak test position
            tMonitorTime := GVL_Settings.tLeakTestMonitorTime, // Configurable monitoring time
            rPressureLimit := GVL_Settings.rLeakTestPressureLimit, // Minimum required pressure limit
            bLeakTestDone => bTestCompleted,
            bLeakTestError => bTestFailed,
            sLTMessageError => sTestErrorMessage
        );

        // Transition to the next state if the test is completed successfully
        IF bTestCompleted THEN
            CurrentState := E_MachineStates.RECOVERY_PHASE;
        
        // If the test fails, log the error and transition to ERROR state
        ELSIF bTestFailed THEN
            CurrentState := E_MachineStates.ERROR_STATE;
        END_IF;
	*)
    E_MachineStates.RECOVERY_PHASE:
       (*
		 //Setup and execute FB_RecoveryPhase
        fbRecoveryPhase(
            RecipeParameters := GVL_RecipeParameters,  	//recipe parameters reference 
            aValveConfigs := ValveConfigs,             	//6position valves reference
            aSolenoidSets := aSolenoidSets,            	//passing solenoids sets 
            bExecute := TRUE                           	//init trigger
        );

        //checking the RecoveryPhaseFB results
        bRecoverySuccess := RecoveryPhaseFB.bSuccess;
        bRecoveryError := RecoveryPhaseFB.bError;

        //state transitions based oon fb returns
        IF bRecoveryError THEN
            CurrentState := E_MachineStates.ERROR_STATE;
            GVL_IO.gDigOutputs.bTowerRedLight := TRUE; //raise alarm/red light
        ELSIF bRecoverySuccess THEN
            CurrentState := E_MachineStates.DRYING_PHASE; //step forward to step ahead
        END_IF;
	*)
    E_MachineStates.WASHING_PHASE: //TODO
        IF TRUE THEN //washing sequence
            CurrentState := E_MachineStates.DRYING_PHASE;
        ELSE
            bErrorFlag := TRUE;
            CurrentState := E_MachineStates.ERROR_STATE;
        END_IF;

    E_MachineStates.DRYING_PHASE: //TODO
        IF TRUE THEN //drying sequence
            CurrentState := E_MachineStates.POST_EXECUTION;
        ELSE
            bErrorFlag := TRUE;
            CurrentState := E_MachineStates.ERROR_STATE;
        END_IF;

    E_MachineStates.POST_EXECUTION: //TODO
        IF TRUE THEN //post execution sequence
            CurrentState := E_MachineStates.INIT;
        ELSE
            bErrorFlag := TRUE;
            CurrentState := E_MachineStates.ERROR_STATE;
        END_IF;

    E_MachineStates.ERROR_STATE: //TODO
        GVL_IO.gDigOutputs.bTowerRedLight := TRUE; //red light
		
		//Event Trigger Info State - Error State
		sSystem := 'StateMachine.Error'; sMessage := 'Error State!';
		fbEventHandler( bExecute := bExecuteEvent, eEventName := E_Events.ERROR, sSystem := sSystem, sMessage := sMessage, bDone => bEventDone);
		ResetEventTrigger();
		
        IF GVL_IO.gDigInputs.bStopButton THEN
            bErrorFlag := FALSE;
            CurrentState := E_MachineStates.INIT;
        END_IF;
END_CASE;]]></ST>
    </Implementation>
    <Action Name="ResetEventTrigger" Id="{2d5034a6-643b-4aff-aeda-4e9dc3f48beb}">
      <Implementation>
        <ST><![CDATA[IF bEventDone THEN
        bExecuteEvent := FALSE;
        bEventDone := FALSE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="PRG_StateMachine">
      <LineId Id="1406" Count="7" />
      <LineId Id="1164" Count="0" />
      <LineId Id="1414" Count="0" />
      <LineId Id="1392" Count="2" />
      <LineId Id="1390" Count="1" />
      <LineId Id="1165" Count="1" />
      <LineId Id="1384" Count="0" />
      <LineId Id="1386" Count="0" />
      <LineId Id="1473" Count="0" />
      <LineId Id="1404" Count="0" />
      <LineId Id="1399" Count="1" />
      <LineId Id="1402" Count="1" />
      <LineId Id="1401" Count="0" />
      <LineId Id="1395" Count="0" />
      <LineId Id="1405" Count="0" />
      <LineId Id="1396" Count="2" />
      <LineId Id="1385" Count="0" />
      <LineId Id="1167" Count="0" />
      <LineId Id="1472" Count="0" />
      <LineId Id="1416" Count="0" />
      <LineId Id="1168" Count="33" />
      <LineId Id="1470" Count="0" />
      <LineId Id="1202" Count="0" />
      <LineId Id="1471" Count="0" />
      <LineId Id="1203" Count="45" />
      <LineId Id="1474" Count="0" />
      <LineId Id="1249" Count="2" />
      <LineId Id="1265" Count="7" />
      <LineId Id="1475" Count="0" />
      <LineId Id="1273" Count="3" />
      <LineId Id="1550" Count="0" />
      <LineId Id="1477" Count="0" />
      <LineId Id="1551" Count="0" />
      <LineId Id="1479" Count="1" />
      <LineId Id="1478" Count="0" />
      <LineId Id="1278" Count="12" />
      <LineId Id="1537" Count="0" />
      <LineId Id="1553" Count="1" />
      <LineId Id="1539" Count="10" />
      <LineId Id="1538" Count="0" />
      <LineId Id="1291" Count="11" />
      <LineId Id="1304" Count="79" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="PRG_StateMachine.ResetEventTrigger">
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>