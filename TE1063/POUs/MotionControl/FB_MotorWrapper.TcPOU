<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_MotorWrapper" Id="{e1ed2152-e06a-419a-985a-88258f9f2422}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotorWrapper IMPLEMENTS IF_Actuator
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	Axis : AXIS_REF;
END_VAR

VAR
	// MC2 Motion Function Blocks
    fbPower       : MC_Power;
    fbReset       : MC_Reset;
    fbMoveAbs     : MC_MoveAbsolute;
    fbMoveRel     : MC_MoveRelative;
	fbMoveVel	  : MC_MoveVelocity;
    fbHome        : MC_Home;
	fbReadPos	  : MC_ReadActualPosition;
    fbStop        : MC_Stop;
	fbHalt		  : MC_Halt;
    rTrigStop     : R_TRIG;

    fSetPosAbs    : LREAL;
    fSetPosRel    : LREAL;
    bAbsRequest   : BOOL;
    bRelRequest   : BOOL;
    bPowerRequest : BOOL;
    bResetRequest : BOOL;
    bDisableReq   : BOOL;
	
	//Stop()
    bStopExecute     : BOOL;
    bStopRequested   : BOOL;
	bStopDone		 : BOOL;

    status        	 : ST_ActuatorStatus;
    debugSensorValue : BOOL;
	
	//Home()
	bStartDelay		 : BOOL := FALSE;
	tonHoming 		 : TON;
	bhomeExecute	 : BOOL := FALSE;

	bExecuteMove	 : BOOL;
	bHomeSensorValue : BOOL;
	bHomeInProgress  : BOOL := FALSE;
	bStartMoveVel	 : BOOL;
	bWaitingForSensorOff : BOOL;
	bWaitingForStop	: BOOL;
	bStartHoming	: BOOL;
	
	//MoveAbs()
	bMoveAbsExecute 	: BOOL;
    bMoveAbsRequested 	: BOOL;
	bMoveAbsDone		: BOOL;
	
	//MoveValve()
	rTargetAngle		: LREAL;
	bMoveValveExecute 	: BOOL;
    bMoveValveRequested : BOOL;
	
	//Reset()
	bResetExecute 		: BOOL;
    bResetRequested 	: BOOL;
	bResetDone			: BOOL;
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Disable" Id="{1dc75d36-67d4-446b-8c6d-65221bad79c5}">
      <Declaration><![CDATA[METHOD Disable : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Disable (Remove power from axis)
fbPower(Axis := Axis, Enable := FALSE);
status.bEnabled := FALSE;
status.eState := E_ActuatorState.eDisabled;
Disable := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{d67ddf43-bc97-4342-80c6-577e8cfb8a1b}">
      <Declaration><![CDATA[METHOD Enable : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Call MC_Power to enable axis
fbPower(Axis := Axis, Enable := TRUE, Enable_Positive := TRUE, Enable_Negative := TRUE);
status.bEnabled := fbPower.Status;
status.bError := fbPower.Error;
status.iErrorCode := fbPower.ErrorID;
IF fbPower.Error THEN
	status.eState := E_ActuatorState.eError;
	status.sMessage := 'Error in PowerUp';
ELSE
	status.eState := E_ActuatorState.eActive;
END_IF;

Enable := fbPower.Status;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetPosition" Id="{4edb2a8e-f8bf-4431-b71c-db3c2d022d41}">
      <Declaration><![CDATA[METHOD GetPosition : LREAL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Get Actual Position of the motor
fbReadPos(Axis := Axis, Enable := TRUE);
GetPosition := fbReadPos.Position;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetStatus" Id="{a9f2bdab-8820-4977-9409-a8793adba31f}">
      <Declaration><![CDATA[METHOD GetStatus : ST_ActuatorStatus
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Get unified status struct with all feedback for HMI/diagnostics
fbReadPos(Axis := Axis, Enable := TRUE);
status.fPosition := fbReadPos.Position;
status.bBusy := fbMoveAbs.Busy OR fbMoveRel.Busy OR fbHome.Busy;
status.bDone := fbMoveAbs.Done OR fbMoveRel.Done OR fbHome.Done;
status.bError := fbPower.Error OR fbMoveAbs.Error OR fbMoveRel.Error OR fbHome.Error;
// Prioritize error messages by source
IF status.bError THEN
	status.eState := E_ActuatorState.eError;
	IF fbPower.Error THEN
		status.sMessage := 'Error in PowerUp';
	ELSIF fbMoveAbs.Error THEN
		status.sMessage := 'Error in MoveAbsolute';
	ELSIF fbMoveRel.Error THEN
		status.sMessage := 'Error in MoveRelative';
	ELSIF fbHome.Error THEN
		status.sMessage := 'Error in Home';
	END_IF
END_IF;
//return
GetStatus := status;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{771f97a4-e7d4-481b-b233-9c33c798e61d}">
      <Declaration><![CDATA[METHOD Home : BOOL
VAR_INPUT
	bHomeRequest : BOOL;
	pHomeSensor : POINTER TO BOOL; // home sensor pointer
END_VAR
VAR
	 rTrigHome : R_TRIG;
	 rTrigMove : R_TRIG;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bHomeSensorValue  := pHomeSensor^;
IF NOT bHomeRequest THEN
	Home := FALSE;
END_IF

IF NOT GVL_Motion.bInitialHomingDone THEN
	
	IF bHomeRequest AND NOT bHomeInProgress AND bHomeSensorValue THEN
		bExecuteMove 	:= TRUE;
		bHomeInProgress := TRUE;
	END_IF
	
	IF bHomeRequest AND NOT bHomeInProgress THEN
		bExecuteMove 	:= FALSE;
	
		// If the sensor is already active, skip movement and go to homing directly
		IF NOT bHomeSensorValue THEN
			bStartDelay := TRUE;
			bHomeInProgress := TRUE;
		ELSE
			bExecuteMove := TRUE;
			bHomeInProgress := TRUE;
		END_IF
	END_IF
	
	IF bHomeSensorValue THEN
		fbMoveVel(Axis := Axis, Execute := bExecuteMove, Velocity := 15.0, Acceleration := 20.0, Deceleration := 20.0, direction := 1);
		status.sMessage := 'Seeking home sensor...';
		bStopExecute := TRUE;
	ELSE
		bExecuteMove := FALSE;
		fbStop(Axis := Axis, Execute := bStopExecute, Deceleration := 10);
	END_IF
	
	IF fbStop.Done THEN
		bStopExecute := FALSE;
		bStartDelay := TRUE;
	END_IF
	
	IF NOT fbStop.Busy THEN
		tonHoming(IN := bStartDelay, PT := T#2S);
	END_IF
	
	IF tonHoming.Q THEN
		bhomeExecute := TRUE;
		status.sMessage := 'Executing MC_Home...';
	END_IF
	
	fbHome(Axis := Axis, Execute := bhomeExecute, Position := 0.0, HomingMode := MC_Direct);
	
	IF fbHome.Done THEN
		status.eState := E_ActuatorState.eIdle;
		status.bError := FALSE;
		status.bDone := TRUE;
		status.sMessage := 'Homing completed';
		bStartDelay  := FALSE;
		bhomeExecute := FALSE;
		tonHoming.IN := FALSE;
		bHomeInProgress := FALSE;
		GVL_Motion.bMotorsHomeDone := TRUE;
		Home := TRUE;
	ELSIF fbHome.Error THEN
		status.eState := E_ActuatorState.eError;
		status.bError := TRUE;
		status.iErrorCode := fbHome.ErrorID;
		status.sMessage := 'Error in Homing';
		bhomeExecute := FALSE;
		bStartDelay  := FALSE;
		tonHoming.IN := FALSE;
		bHomeInProgress := FALSE;
		Home := FALSE;
	ELSE
		Home := FALSE;
	END_IF
ELSE
	
	IF fbMoveAbs.Done THEN 
		bHomeinProgress := FALSE;
		Home := TRUE;
	END_IF
	
	rTrigMove(CLK := bHomeRequest AND NOT bHomeInProgress);
	
	// If homing previously done then Move to zero position
	fbMoveAbs(Axis := Axis, Execute := rTrigMove.Q, Position := 0, velocity := 15, Acceleration := 15, Deceleration := 15);
	bHomeinProgress := TRUE;
	

	
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAbsolute" Id="{3c2d0047-9043-4f3b-b941-8126a4eab227}">
      <Declaration><![CDATA[METHOD MoveAbsolute : BOOL
VAR_INPUT
	Position : LREAL;
    Velocity : LREAL := 10.0;
    Acc      : LREAL := 20.0;
    Dec      : LREAL := 20.0;
END_VAR
VAR
    Execute : BOOL := TRUE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Absolute motion command (position, velocity, acceleration, deceleration)
// Gera o pulso uma vez quando solicitado
IF NOT bMoveAbsRequested THEN
    bMoveAbsExecute := TRUE;
    bMoveAbsRequested := TRUE;
END_IF

// Chamada do bloco
fbMoveAbs(
    Axis := Axis,
    Position := Position,
    Execute := bMoveAbsExecute,
    Velocity := Velocity,
    Acceleration := Acc,
    Deceleration := Dec
);

// Atualiza status
status.bBusy := fbMoveAbs.Busy;
status.bDone := fbMoveAbs.Done;
status.bError := fbMoveAbs.Error;
status.iErrorCode := fbMoveAbs.ErrorID;

IF fbMoveAbs.Busy THEN
	bMoveAbsExecute := FALSE;
END_IF

IF fbMoveAbs.Error THEN
    status.eState := E_ActuatorState.eError;
    status.sMessage := 'Error in MoveAbsolute';
END_IF

IF bMoveAbsRequested AND NOT fbMoveAbs.Busy AND NOT fbMoveAbs.Error THEN
    bMoveAbsRequested := FALSE;
    MoveAbsolute := TRUE;
	RETURN;
ELSE
    MoveAbsolute := FALSE;
END_IF




]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveRelative" Id="{f57948ef-5e1c-4cbd-b496-9bd6108f8456}">
      <Declaration><![CDATA[METHOD MoveRelative : BOOL
VAR_INPUT
	Distance : LREAL;
    Velocity : LREAL := 10.0;
    Acc      : LREAL := 20.0;
    Dec      : LREAL := 20.0;
END_VAR
VAR
    Execute : BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Relative motion command (distance, velocity, acceleration, deceleration)
fbMoveRel(Axis := Axis, Distance := Distance, Execute := Execute, Velocity := Velocity, Acceleration := Acc, Deceleration := Dec);
status.bBusy := fbMoveRel.Busy;
status.bDone := fbMoveRel.Done;
status.bError := fbMoveRel.Error;
status.iErrorCode := fbMoveRel.ErrorID;
IF fbMoveRel.Error THEN
	status.eState := E_ActuatorState.eError;
	status.sMessage := 'Error in MoveRelative';
END_IF;

//Return
MoveRelative := fbMoveRel.Done;]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveValve" Id="{0efdf2ac-cd7b-4dd3-893f-1eab65963717}">
      <Declaration><![CDATA[METHOD MoveValve : BOOL
VAR_INPUT
	iPosition : USINT;
	rVelocity : LREAL;
	rAcc	  : LREAL;
	rDec	  : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Map logical valve position to angular position
CASE iPosition OF
    1: rTargetAngle := 0.0;
    2: rTargetAngle := 60.0;
    3: rTargetAngle := 120.0;
    4: rTargetAngle := 180.0;
    5: rTargetAngle := 240.0;
    6: rTargetAngle := 300.0;
ELSE
    rTargetAngle := 0.0;
END_CASE

// Reuse the same logic from MoveAbsolute
IF NOT bMoveValveRequested THEN
    bMoveValveExecute := TRUE;
    bMoveValveRequested := TRUE;
END_IF

// Call the internal motion block
fbMoveAbs(
    Axis := Axis,
    Position := rTargetAngle,
    Execute := bMoveValveExecute,
    Velocity := rVelocity,
    Acceleration := rAcc,
    Deceleration := rDec
);

// Update actuator status
status.bBusy := fbMoveAbs.Busy;
status.bDone := fbMoveAbs.Done;
status.bError := fbMoveAbs.Error;
status.iErrorCode := fbMoveAbs.ErrorID;

IF fbMoveAbs.Busy THEN
    bMoveValveExecute := FALSE;
END_IF

IF fbMoveAbs.Error THEN
    status.eState := E_ActuatorState.eError;
    status.sMessage := 'Error in MoveValve';
END_IF

IF bMoveValveRequested AND NOT fbMoveAbs.Busy AND NOT fbMoveAbs.Error THEN
    bMoveValveRequested := FALSE;
    MoveValve := TRUE;
    RETURN;
ELSE
    MoveValve := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{55ea212e-113c-4739-bf54-01562c1314f2}">
      <Declaration><![CDATA[METHOD Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Generates the pulse just once when it's called
IF NOT bResetRequested THEN
    bResetExecute := TRUE;
    bResetRequested := TRUE;
END_IF

// Reset errors on the axis and motion FBs
IF bResetRequested THEN
    fbReset(Axis := Axis, Execute := bResetExecute);

    status.bError := fbReset.Error;
    status.iErrorCode := fbReset.ErrorID;

    IF fbReset.Error THEN
        status.eState := E_ActuatorState.eError;
        status.sMessage := 'Error in Reset';
        Reset := FALSE;
    ELSE
        status.bError := FALSE;
        status.iErrorCode := 0;
        status.eState := E_ActuatorState.eIdle;
        status.sMessage := '';
    END_IF;
	
	IF bResetDone THEN
        // Flags clearing  
        bResetRequested := FALSE;
        bResetDone := FALSE;
        Reset := TRUE;
        RETURN;
    END_IF
	
    IF fbReset.Done THEN
        bResetExecute := FALSE;
        bResetDone := TRUE;
    END_IF
    
END_IF

Reset := FALSE;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Stop" Id="{27336d58-d763-4c6d-b6e1-79be37906c83}">
      <Declaration><![CDATA[METHOD Stop : BOOL
VAR_INPUT
END_VAR
VAR
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bStopRequested THEN
	bStopExecute := TRUE;
	bStopRequested := TRUE;
END_IF

IF bStopRequested THEN
	fbStop(Axis := Axis, Execute := bStopExecute);
END_IF

IF bStopDone AND NOT fbStop.Busy THEN
	bStopRequested := FALSE;
END_IF

IF fbStop.Done THEN
	bStopExecute := FALSE;
	bStopDone := TRUE;
END_IF

status.bError := fbStop.Error;
status.iErrorCode := fbStop.ErrorID;

IF fbStop.Error THEN
	status.eState := E_ActuatorState.eError;
	status.sMessage := 'Error in Stop';
	Stop := FALSE;
END_IF

IF bStopDone AND NOT fbStop.Busy AND NOT bStopRequested THEN
	status.bError := FALSE;
	status.iErrorCode := 0;
	status.eState := E_ActuatorState.eIdle;
	status.sMessage := 'Axis Stopped';
	bStopDone := FALSE;
	Stop := TRUE;
	RETURN;
ELSE
	Stop := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MotorWrapper">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.Disable">
      <LineId Id="9" Count="0" />
      <LineId Id="6" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.Enable">
      <LineId Id="6" Count="11" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.GetPosition">
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.GetStatus">
      <LineId Id="6" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="8" Count="16" />
      <LineId Id="27" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.Home">
      <LineId Id="371" Count="0" />
      <LineId Id="505" Count="2" />
      <LineId Id="428" Count="0" />
      <LineId Id="427" Count="0" />
      <LineId Id="484" Count="0" />
      <LineId Id="431" Count="3" />
      <LineId Id="508" Count="0" />
      <LineId Id="510" Count="0" />
      <LineId Id="519" Count="0" />
      <LineId Id="512" Count="3" />
      <LineId Id="520" Count="0" />
      <LineId Id="516" Count="1" />
      <LineId Id="521" Count="0" />
      <LineId Id="518" Count="0" />
      <LineId Id="509" Count="0" />
      <LineId Id="435" Count="48" />
      <LineId Id="429" Count="0" />
      <LineId Id="485" Count="0" />
      <LineId Id="503" Count="0" />
      <LineId Id="500" Count="1" />
      <LineId Id="504" Count="0" />
      <LineId Id="499" Count="0" />
      <LineId Id="502" Count="0" />
      <LineId Id="488" Count="0" />
      <LineId Id="493" Count="0" />
      <LineId Id="487" Count="0" />
      <LineId Id="491" Count="0" />
      <LineId Id="494" Count="1" />
      <LineId Id="498" Count="0" />
      <LineId Id="486" Count="0" />
      <LineId Id="430" Count="0" />
      <LineId Id="372" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.MoveAbsolute">
      <LineId Id="6" Count="0" />
      <LineId Id="52" Count="14" />
      <LineId Id="127" Count="0" />
      <LineId Id="73" Count="4" />
      <LineId Id="128" Count="2" />
      <LineId Id="107" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="79" Count="7" />
      <LineId Id="124" Count="0" />
      <LineId Id="87" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.MoveRelative">
      <LineId Id="6" Count="0" />
      <LineId Id="17" Count="8" />
      <LineId Id="34" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="33" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.MoveValve">
      <LineId Id="31" Count="44" />
      <LineId Id="77" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.Reset">
      <LineId Id="36" Count="22" />
      <LineId Id="83" Count="0" />
      <LineId Id="77" Count="5" />
      <LineId Id="76" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="60" Count="3" />
      <LineId Id="71" Count="3" />
      <LineId Id="21" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MotorWrapper.Stop">
      <LineId Id="85" Count="3" />
      <LineId Id="118" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="119" Count="1" />
      <LineId Id="122" Count="3" />
      <LineId Id="91" Count="2" />
      <LineId Id="121" Count="0" />
      <LineId Id="94" Count="8" />
      <LineId Id="127" Count="1" />
      <LineId Id="103" Count="6" />
      <LineId Id="126" Count="0" />
      <LineId Id="110" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>